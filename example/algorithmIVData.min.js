/* Algorithm IV (v1.0.1) (learn@algorithmiv.com)
 * Section: User Data, App Initialization, & Web Worker
 * Author: Adam Smith (adamsmith@youlum.com)
 * Copyright (c) 2015 Adam A Smith (github.com/imaginate)
 * The MIT License (algorithmiv.com/docs/license) */

/**
 * ------------------------------------------------------------------
 * Algorithm IV User Data (v1.0.1)
 * ------------------------------------------------------------------
 * manages a list of practice questions and detailed solutions
    for learning computer science focused algorithms and data
    structures, improving programming skillsets, and preparing
    for technical interviews
 * settings: configuration, categories, sources, and questions
 * directions:
   - see algorithmiv.com/docs/start
 */
(function() {
  "use strict";

  /**
   * -----------------------------------------------
   * Public Variable (configuration)
   * -----------------------------------------------
   * an object containing the configuration settings
      for this module
   * details:
     - see algorithmiv.com/docs/configuration
   */
  var configuration = {
    searchSettings: {
         stage: true,
        source: true,
      category: true,
        subCat: true
    },
    searchDefaults: {
         view: 'one',
        order: 'asc',
        stage: 'all',
       source: 'all',
      mainCat: 'all',
       subCat: 'all',
      startID: 0
    },
    questionFormat: {
            id: true,
      complete: true,
        source: true,
      category: true,
         links: true,
        output: true
    },
        id: true,
    worker: true
  };

  /**
   * -----------------------------------------------
   * Public Variable (sources)
   * -----------------------------------------------
   * an object containing all of the problem sources
   * details:
     - see algorithmiv.com/docs/sources
   */
  var sources = {
    'am': 'Amazon',
    'bl': 'Bloomberg',
    'fb': 'Facebook',
    'go': 'Google'
  };

  /**
   * -----------------------------------------------
   * Public Variable (categories)
   * -----------------------------------------------
   * an object containing each main and sub question
     category
   * details:
     - see algorithmiv.com/docs/categories
   */
  var categories = {
    main: {
      'array' : 'Arrays',
      'graph' : 'Graphs',
      'hash'  : 'Hashes',
      'list'  : 'Linked Lists',
      'search': 'Searching Algorithms',
      'sort'  : 'Sorting Algorithms',
      'tree'  : 'Trees'
    },
    sub: {
      'graph': {
        'adjList': 'Adjacency Lists',
        'adjMtrx': 'Adjacency Matrices',
        'arb'    : 'Arborescences',
        'digraph': 'Directed Graphs',
        'incList': 'Incidence Lists',
        'incMtrx': 'Incidence Matrices',
        'ungraph': 'Undirected Graphs'
      },
      'hash': {
        'dblHash': 'Double Hashing',
        'fnv'    : 'FNV Hash Algorithms',
        'hTable' : 'Hash Tables'
      },
      'list': {
        'sList': 'Singly-Linked Lists',
        'dList': 'Doubly-Linked Lists'
      },
      'search': {
        'back'   : 'Backtracking',
        'binSrch': 'Binary Search',
        'bfs'    : 'Breadth First Search',
        'brute'  : 'Brute Force Search',
        'dfs'    : 'Depth First Search',
        'dynam'  : 'Dynamic Programming'
      },
      'sort': {
        'bucket': 'Bucket Sort',
        'heapS' : 'Heapsort',
        'insert': 'Insertion Sort',
        'intro' : 'Introsort',
        'merge' : 'Mergesort',
        'quick' : 'Quicksort',
        'radix' : 'Radix Sort',
        'select': 'Select Sort',
        'smooth': 'Smoothsort'
      },
      'tree': {
        'binHeap': 'Binary Heaps',
        'binTree': 'Binary Trees',
        'bst'    : 'Binary Search Trees',
        'bnmHeap': 'Binomial Heaps',
        'fibHeap': 'Fibonacci Heaps',
        'red'    : 'Red-Black Trees',
        'splay'  : 'Splay Trees',
        'trie'   : 'Tries'
      }
    }
  };

  /**
   * ---------------------------------------------
   * Public Variable (questions)
   * ---------------------------------------------
   * an array of objects containing each question,
      its details, and your solution for it
   * details:
     - see algorithmiv.com/docs/questions
   */
  var questions = [
    {
      // Question: 1
      complete: true,
        source: 'fb',
       mainCat: [ 'search', 'tree', 'list', 'array' ],
        subCat: [ 'bfs', 'binTree', 'sList' ],
         links: [
           {
             name: 'Further Discussion',
             href: 'http://www.careercup.com/question?id=4505011482525696'
           }
         ],
       problem: 'Given an array of values, create a balanced binary tree and print each row of the tree in order. Terminate each row with a carriage return.',
      solution: function() {
        /*
         ** Solution:
         *  - Step 1: A Breadth First Search algorithm is used
         *    to create a balanced binary tree. A linked list
         *    of nodes containing their value and references
         *    to their left and right children is used to
         *    represent the binary tree.
         *  - Step 2: A Breadth First Search algorithm is used
         *    to traverse the tree and add the nodes in order
         *    by row to the result.
         *
         ** Need to Know Terms:
         *  - Algorithms:
         *    -- Breadth First Search (BFS): http://en.wikipedia.org/wiki/Breadth-first_search
         *  - Data Structures:
         *    -- Binary Tree: http://en.wikipedia.org/wiki/Binary_tree
         *    -- Singly-Linked Lists: http://en.wikipedia.org/wiki/Linked_list#Singly_linked_list
         *    -- Linked Lists: http://en.wikipedia.org/wiki/Linked_list
         *    -- Arrays: http://en.wikipedia.org/wiki/Array_data_structure
         */

        // The given values
        // The binary tree
        // The node rows to be printed
        var vals, tree, result;

        // Set variables
        vals = [ 'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O' ];
        tree = {
          val  : vals[0],
          left : null,
          right: null
        };
        result = '';

        // Creates the binary tree
        function createTree() {
          // A function that adds children to a node
          // The temporary holder for each row of nodes
          // The index of the current value
          // The current tree's depth
          // The tree's max depth
          // The current node
          var addNodes, row, val, d, depth, node;

          // Adds children to the provided node
          // param: The node to add the children
          addNodes = function(prtNode) {

            // Create the nodes and increase the value
            prtNode.left = {
              val  : vals[val],
              left : null,
              right: null
            };
            ++val;
            prtNode.right = {
              val  : vals[val],
              left : null,
              right: null
            };
            ++val;

            // Add the nodes to temp holder
            row.next.push(prtNode.left, prtNode.right);
          };

          // Set the temp holders, value, and max depth
          row = {
            now : [tree],
            next: []
          };
          val = 1;
          depth = 4;

          // Add the nodes to tree
          for (d=1; d<depth; d++) {
            // Add nodes
            row.now.forEach(function(node) {
              addNodes(node);
            });
            // Reset temp arrays
            row.now = row.next.slice(0);
            row.next = [];
          }
        }

        // Saves a string of the binary tree's nodes
        //   in order with a line break for each row
        function printNodes() {
          // The current and next row of nodes
          // The current node being searched
          // The left child
          // The right child
          var row, node, left, right;

          // Set final result
          result = tree.val;

          // Set temp holder for each row
          row = {
              now   : [tree],
              next  : [],
              string: ''
            };

          // Loop through nodes
          loop:
          while (true) {

            // Set and remove node
            node = row.now.shift();

            // If (child exists)
            // Then {add child to next row and result}
            if (!!node.left) {
              row.next.push(node.left);
              row.string += (row.next.length > 1) ? ',' : '';
              row.string += node.left.val;
            }
            if (!!node.right) {
              row.next.push(node.right);
              row.string += (row.next.length > 1) ? ',' : '';
              row.string += node.right.val;
            }

            // If (current row finished)
            // Then {check, update, and reset rows}
            // Else {end search}
            if (row.now.length === 0) {
              if (row.next.length > 0) {
                result += '<br />' + row.string;
                row.now = row.next.slice(0);
                row.next = [];
                row.string = '';
              }
              else {
                break loop;
              }
            }
          }
        }

        // Create tree and print nodes
        createTree();
        printNodes();
        return result;
      }
    },
    {
      // Question: 2
      complete: true,
        source: 'am',
       mainCat: [ 'search', 'graph', 'list', 'array' ],
        subCat: [ 'back', 'dynam', 'dfs', 'digraph', 'incList', 'sList', 'dList' ],
         links: [
           {
             name: 'Further Discussion',
             href: 'http://www.careercup.com/question?id=6031402409656320'
           }
         ],
       problem: 'Imagine a large city like Los Angeles. Suppose someone shows up at location A, then N minutes later at location B. Design a function that approximates the probability they passed a Starbucks.',
      solution: function() {
        /*
         ** Solution:
         *  - Step 1: A time weighted digraph of locations
         *    and a boolean value for whether a Starbucks is
         *    passed for each edge is created. An array of
         *    vertex nodes (storing its value and a reference
         *    to each of its edges) and edge nodes (storing
         *    its weight, Starbuck's value, and a reference
         *    to each of its connecting nodes) is used to
         *    implement the digraph.
         *  - Step 2: A recursive dynamic backtracking DFS
         *    algorithm is applied to traverse the digraph
         *    and find all of the paths possible to the
         *    destination within the provided maximum time
         *    frame and whether a Starbucks was passed on
         *    each path.
         *  - Step 3: The probability of passing a Starbucks
         *    is calculated.
         *
         ** Need to Know Terms:
         *  - Algorithms:
         *    -- Backtracking: http://en.wikipedia.org/wiki/Backtracking
         *    -- Dynamic Programming: http://en.wikipedia.org/wiki/Dynamic_programming
         *    -- Depth First Search (DFS): http://en.wikipedia.org/wiki/Depth-first_search
         *  - Data Structures:
         *    -- Directed Graph (Digraph): http://en.wikipedia.org/wiki/Directed_graph
         *    -- Weighted Graph: http://en.wikipedia.org/wiki/Glossary_of_graph_theory#Weighted_graphs_and_networks
         *    -- Incidence List: http://www.algorithmist.com/index.php/Graph_data_structures#Incidence_List
         *    -- Singly-Linked Lists: http://en.wikipedia.org/wiki/Linked_list#Singly_linked_list
         *    -- Doubly-Linked List: http://en.wikipedia.org/wiki/Doubly_linked_list
         *    -- Linked Lists: http://en.wikipedia.org/wiki/Linked_list
         *    -- Arrays: http://en.wikipedia.org/wiki/Array_data_structure
         */

        // The time weighted digraph
        // The starting vertex (starting location)
        // The final vertex (final destination)
        // The maximum weight of a path (minutes of time)
        // The final paths
        // The probability of passing a Starbucks
        // The visually prepared final results
        var graph, start, end, max, paths, prob, results;

        // Set variables
        graph = {
          verti: [],
          edges: []
        };
        start =  0;
        end   =  9;
        max   = 50;
        paths = {
          list  : [],
          starbk: 0
        };
        prob  = 0;
        results = {
          count: {
            all   : '',
            starbk: ''
          },
          prob : '',
          paths: {
            all   : '',
            starbk: ''
          }
        };

        // Creates the weighted digraph
        function createGraph() {
          // The vertex index
          // The edge index
          // The edge's parent vertex
          // The edge's child vertex
          // The edge's weight
          // The edge's Starbuck's value
          var v, e, prt, child, weight, starbk;
          // The parent index
          // The child index
          // A function that adds edge
          //   pointers to vertices
          var p, c, addPointer;
          
          // Adds a vertex's edge references
          // param: The vertex's index
          // param: An array of edge indexes
          addPointer = function(vertex, edges) {
            // The number of edges
            // The loop index
            // The edge node
            var len, i, node;
            
            // Save edges count
            len = edges.length;
            // Add each edge
            for (i=0; i<len; i++) {
              node = graph.edges[ edges[i] ];
              graph.verti[vertex].edges.push(node);
            }
          }

          // Add vertices to graph
          for (v=0; v<10; v++) {
            graph.verti.push({ val: v, edges: [] });
          }

          // Add edges to graph
          for (e=0; e<16; e++) {

            // Set weight and starbucks
            weight = 5;
            starbk = (e === 5);
            // Set parent and child
            switch (true) {
              case (e < 3):
                p = 0;
                c = (e === 0) ? 1 : ++c;
                prt = graph.verti[p];
                child = graph.verti[c];
              break;
              case (e < 5):
                p = 1;
                c = e;
                prt = graph.verti[p];
                child = graph.verti[c];
              break;
              case (e < 7):
                p = 2;
                c = e;
                prt = graph.verti[p];
                child = graph.verti[c];
              break;
              case (e === 7):
                p = 3;
                c = 6;
                prt = graph.verti[p];
                child = graph.verti[c];
              break;
              case (e === 8):
                p = 4;
                c = 6;
                prt = graph.verti[p];
                child = graph.verti[c];
              break;
              case (e < 12):
                p = 5;
                c = ++c;
                prt = graph.verti[p];
                child = graph.verti[c];
              break;
              case (e < 14):
                p = 6;
                c = (e === 12) ? 7 : 9;
                prt = graph.verti[p];
                child = graph.verti[c];
              break;
              case (e === 14):
                p = 7;
                c = 8;
                prt = graph.verti[p];
                child = graph.verti[c];
              break;
              case (e === 15):
                p = 8;
                c = 9;
                prt = graph.verti[p];
                child = graph.verti[c];
              break;
            }
            // Add edge
            graph.edges.push({
              prt   : prt,
              child : child,
              weight: weight,
              starbk: starbk
            });
          }

          // Add edge pointers to vertices
          addPointer(0, [ 0,1,2 ]);
          addPointer(1, [ 3,4 ]);
          addPointer(2, [ 5,6 ]);
          addPointer(3, [ 7 ]);
          addPointer(4, [ 8 ]);
          addPointer(5, [ 9,10,11 ]);
          addPointer(6, [ 12,13 ]);
          addPointer(7, [ 14 ]);
          addPointer(8, [ 15 ]);
        }

        // Finds all of the paths possible
        //   within the max time
        function findPaths() {
          // The path being currently reviewed
          // A function that is called recursively
          //   to find each path
          var path, buildPaths;

          // Set the recursive DFS
          // param: The current node
          // param: The current cumulative weight
          // param: Whether a starbucks currently exists
          buildPaths = function(node, weight, starbk) {
            // The string for the current path
            // The count of the node's edges
            // The edges index
            // The current edge's node
            // The new total path weight
            // The new starbucks value
            var edges, e, edge, newWeight, newStarbk;

            // If (weight is greater than max weight)
            // Then {end this path traversal}
            if (weight > max) {
              return;
            }

            // If (node is destination)
            // Then {add path to results and end traversal}
            if (node.val === end) {

              // Save string of path
              path.string = '[ ' +
                path.values.join(',') + ',' + end +
              ' ]';

              // Add path to final list of paths
              paths.list.push({
                val   : path.string,
                starbk: starbk
              });
              // Adjust count of Starbucks paths
              paths.starbk += (starbk) ? 1 : 0;

              // End this path traversal
              return;
            }

            // Add node to current path
            path.nodes.push(node);
            path.values.push(node.val);

            // Save the node's count of edges
            edges = node.edges.length;
            // Traverse each path rooting with each edge
            for (e=0; e<edges; e++) {
              // Save reference of edge's object
              edge = node.edges[e];
              // Set new weight total
              newWeight = weight + edge.weight;
              // Set new value for starbucks
              newStarbk = (starbk || edge.starbk);
              // Continue search
              buildPaths(edge.child, newWeight, newStarbk);
            }

            // Remove current node from path
            path.nodes.pop();
            path.values.pop();
          }

          // Set path to empty
          path = {
            nodes : [],
            values: [],
            string: ''
          };
          // Find the paths
          buildPaths(graph.verti[start], 0, false);
        }

        // Calculates the probability of passing a Starbucks
        function calcProbability() {
          // Divide the number of paths with starbucks
          //   by the number of all paths and round up
          //   to the nearest whole percent
          prob = (paths.starbk / paths.list.length) * 100;
          prob = Math.ceil(prob);
        }

        // Prepares an output for visual appeal
        function prepareResults() {
          // The count of paths
          // The first Starbucks path flag
          // The loop index
          var len, flag, i;

          // Save count of paths
          len = paths.list.length;
          
          // Set count results
          results.count.all = 'Count of All Paths: ' + len + '<br />';
          results.count.starbk = 'Count of All Paths with Starbucks: ';
          results.count.starbk += paths.starbk + '<br />';

          // Set probability result
          results.prob = 'Probability of Passing Starbucks: ' + prob + '%<br />';

          // Set path result headers
          results.paths.all = 'List of All Paths:';
          results.paths.starbk = 'List of All Paths with Starbucks:';
          // Set path result containers
          results.paths.all += '<span style="display:block;margin-left:30px">';
          results.paths.starbk += '<span style="display:block;margin-left:30px">';
          // Set first Starbucks flag
          flag = true;
          // Set path results
          for (i=0; i<len; i++) {
            results.paths.all += (i > 0) ? '<br />' : '';
            results.paths.all += paths.list[i].val;
            if (paths.list[i].starbk) {
              // If (first path with Starbucks)
              // Then {change flag}
              // Else {add line break}
              if (flag) {
                flag = false;
              }
              else {
                results.paths.starbk += '<br />';
              }
              results.paths.starbk += paths.list[i].val;
            }
          }
          // Close path result containers
          results.paths.all += '</span>';
          results.paths.starbk += '</span>';
        }

        // Create digraph, find paths,
        //   calculate probability, and
        //   return the prepared results
        createGraph();
        findPaths();
        calcProbability();
        prepareResults();
        return results.count.all + results.count.starbk +
        results.prob + results.paths.all + results.paths.starbk;
      }
    },
    {
      // Question: 3
      complete: true,
        source: 'go',
       mainCat: [ 'hash', 'search' ],
        subCat: [ 'hTable', 'dblHash', 'fnv', 'brute' ],
         links: [
           {
             name: 'Further Discussion',
             href: 'http://www.careercup.com/question?id=5724911848914944'
           }
         ],
       problem: 'Given a table of [Url =&gt; Content] pairs produce a new table of [Url =&gt; Duplicate Urls] pairs.<br /><br />' +
                'Example Input:<br />' +
                'a.com =&gt; &lt;html&gt;alpha&lt;/html&gt;<br />' +
                'b.com =&gt; &lt;html&gt;beta&lt;/html&gt;<br />' +
                'c.com =&gt; &lt;html&gt;gamma&lt;/html&gt;<br />' +
                'd.com =&gt; &lt;html&gt;alpha&lt;/html&gt;<br />' +
                'e.com =&gt; &lt;html&gt;alpha&lt;/html&gt;<br /><br />' +
                'Example Output:<br />' +
                'a.com =&gt; [ d.com, e.com ]<br />' +
                'b.com =&gt; []<br />' +
                'c.com =&gt; []',
      solution: function() {
        /*
         ** Solution:
         *  - Step 1: A hash table using the original
         *    urls as the keys and their page's content
         *    as the values is created.
         *  - Step 2: A hash table using a 32 bit hash
         *    of the page's content for each key and the
         *    content itself as the value is created. A
         *    modified FNV-1a hash algorithm is used to
         *    hash the content. After each new hash
         *    creation the original hash table is
         *    modified (i.e. the content is replaced
         *    with its hash).
         *  - Step 3: An optimized brute force algorithm
         *    is applied to visit each url and identify
         *    any urls with the duplicate content until
         *    all urls have been marked as unique or
         *    duplicated.
         *
         ** Need to Know Terms:
         *  - Algorithms:
         *    -- FNV Hash Algorithm: http://www.isthe.com/chongo/tech/comp/fnv/
         *    -- Double Hashing: http://en.wikipedia.org/wiki/Double_hashing
         *    -- Brute Force Search: http://en.wikipedia.org/wiki/Brute-force_search
         *  - Data Structures:
         *    -- Hash Table: http://en.wikipedia.org/wiki/Hash_table
         */
        
        // The supplied urls and their page's content
        // The hash table of all page's content
        // The list of urls and their duplicated content
        // The visually prepared duplicate results
        var inputs, hashes, duplicates, results;

        // Set variables
        inputs = {
          // 'url': 'content'
          /// CONVERTED TO
          // 'url': 'hashOfContent'
        };
        hashes = {
          // 'hashOfContent': {
          //   collisions: number,
          //   content   : 'content'
          // }
        };
        duplicates = {
          // 'url': [ 'duplicateUrl', ...]
        };
        results = [];

        // Adds the original list of urls
        function setupInputs() {
          // Add urls to inputs
          inputs['a.com'] = '<html>alpha</html>';
          inputs['b.com'] = '<html>beta</html>';
          inputs['c.com'] = '<html>gamma</html>';
          inputs['d.com'] = '<html>alpha</html>';
          inputs['e.com'] = '<html>alpha</html>';
        }

        // Hashes a string with the FNV-1a hash algorithm
        // param: The string to be hashed
        // param: The hashed collision
        // param: The extra rotations to resolve a collision
        function createHash(string, hash, extras) {
          // A function that XORs each octet and multiplies
          //   by the prime
          // The FNV offset basis for the hash
          // The string length
          // The loop index
          var fnv, offset, len, i;

          // Handles the XOR of each octet and prime
          //   multiplication
          // param: The unicode for a character
          fnv = function(unicode) {
            hash ^= unicode;
            hash *= (hash << 1) + (hash << 4) +
            (hash << 7) + (hash << 8) + (hash << 24);
          };

          // Set offset to the 32 bit FNV offset_value
          offset = 0x811c9dc5;

          // If (no hash supplied)
          // Then {create new hash}
          // Else {resolve collision}
          if (!hash) {

            // Offset the hash
            hash = offset;

            // Save string length
            len = string.length;
            // Loop through each string character
            for (i=0; i<len; i++) {
              // Run fnv action
              fnv( string.charCodeAt(i) );
            }
          }
          else {

            // Loop through each extra time
            for (i=0; i<extras; i++) {
              // Run fnv action
              fnv( string.charCodeAt(i) );
            }
          }

          // Zero-fill right shift hash
          hash = hash >>> 0;

          return hash;
        }

        // Creates a hash table for the url page's content
        function createHashTable() {
          // Function that adds hash to table
          // The current url
          // The current url's content
          // The current content's hash
          var addHash, url, content, hash;

          // Set addHash function
          addHash = function(theUrl, theContent, theHash) {

            // If (hash does not exist in table)
            if (typeof hashes[theHash] === 'undefined') {
              // Add hash key to table
              hashes[theHash] = {
                collisions: 0,
                content: theContent
              };
              // Replace inputs content with hash
              inputs[theUrl] = theHash;
            }
            else {
              // If (no collision)
              // Then {replace inputs content with hash}
              // Else {add collision, create new hash, and repeat process}
              if (theContent === hashes[theHash].content) {
                inputs[theUrl] = theHash;
              }
              else {
                ++hashes[theHash].collisions;
                theHash = createHash(theContent, theHash, hashes[theHash].collisions);
                addHash(theUrl, theContent, theHash);
              }
            }
          };

          // Loop through supplied inputs
          for (url in inputs) {
            // Filter out default javascript properties
            if ( inputs.hasOwnProperty(url) ) {

              // Save, hash, and add the content and 
              //   hash to the hash table
              content = inputs[url];
              hash = createHash(content);
              addHash(url, content, hash);
            }
          }
        }

        // Finds the duplicated url page's content
        function findDuplicates() {
          // The list of the urls to check
          // The current url
          // The current length of the url list
          // The loop index
          // The next url
          // The loop count
          var urls, url, len, i, next, l;

          // Set the url list to empty then
          //   add all the urls to it
          urls = [];
          for (url in inputs) {
            if ( inputs.hasOwnProperty(url) ) {
              urls.push(url);
            }
          }

          // Loop through url list
          while (urls.length > 0) {

            // Save and remove first url on list
            url = urls.shift();
            // Add a property to the duplicates
            //   object with the url as the key
            duplicates[url] = [];

            // Save the current url list length
            len = urls.length;
            // Set index and loop count to 0
            i = l = 0;
            // Loop through url list
            for (; l<len; l++) {

              // Save the next url
              next = urls[i];

              // If (urls content matches)
              // Then {save to duplicates and remove from url list}
              // Else {increase index}
              if (inputs[url] === inputs[next]) {
                duplicates[url].push(next);
                urls.splice(i, 1);
              }
              else {
                ++i;
              }
            }
          }
        }

        // Prepares the results to be returned
        function prepareResults() {
          // The current url
          var url;

          // Add each url to the results array
          for (url in duplicates) {
            if ( duplicates.hasOwnProperty(url) ) {
              results.push(url + ' => [ ' + duplicates[url].join(',') + ' ]');
            }
          }
        }

        // Setup data structures, find duplicated
        //   content, and return visually
        //   prepared results
        setupInputs();
        createHashTable();
        findDuplicates();
        prepareResults();
        return results.join('<br />');
      }
    },
    {
      // Question: 4
      complete: true,
        source: 'go',
       mainCat: [ 'search', 'tree', 'graph', 'hash', 'list', 'array' ],
        subCat: [ 'brute', 'back', 'dfs', 'trie', 'arb', 'digraph', 'adjList', 'hTable', 'sList' ],
         links: [
           {
             name: 'Further Discussion',
             href: 'http://www.careercup.com/question?id=6270813198090240'
           }
         ],
       problem: 'You are given a string of four lower case characters and a dictionary of english words. Choose a data structure to represent the dictionary and write an algorithm that returns all the words from the dictionary that can be formed by the characters of the string.<br />' +
                'Example:<br />' +
                'string = \'ogeg\'<br />' +
                'words = [ \'egg\',\'ego\', ... ]',
      solution: function() {
        /*
         ** Solution:
         *  - Step 1: A json dictionary of English words is
         *    downloaded for use via ajax.
         *  - Step 2: A brute force search algorithm is used
         *    to create a trie of only the words from the
         *    dictionary that have a max of 4 characters
         *    and begin with a letter from the given string.
         *    A hash table with the key set to the current
         *    substring and the value set to a node
         *    containing a boolean value for whether the
         *    substring is a word, the string value of the
         *    substring, and an array of references to its
         *    child nodes is used to represent the trie.
         *  - Step 3: An arborescence is constructed for all
         *    of the characters in the supplied string.
         *  - Step 4: A backtracking algorithm is used to
         *    find all of the possible words resulting from
         *    the arborescence of the supplied string.
         *
         ** Need to Know Terms:
         *  - Algorithms:
         *    -- Brute Force Search: http://en.wikipedia.org/wiki/Brute-force_search
         *    -- Backtracking: http://en.wikipedia.org/wiki/Backtracking
         *    -- Depth First Search (DFS): http://en.wikipedia.org/wiki/Depth-first_search
         *  - Data Structures:
         *    -- Trie: http://www.geeksforgeeks.org/trie-insert-and-search/
         *    -- Arborescence: http://en.wikipedia.org/wiki/Arborescence_(graph_theory)
         *    -- Directed Graph (Digraph): http://en.wikipedia.org/wiki/Directed_graph
         *    -- Adjacency List: http://en.wikipedia.org/wiki/Adjacency_list
         *    -- Hash Table: http://en.wikipedia.org/wiki/Hash_table
         *    -- Singly-Linked Lists: http://en.wikipedia.org/wiki/Linked_list#Singly_linked_list
         *    -- Linked Lists: http://en.wikipedia.org/wiki/Linked_list
         *    -- Arrays: http://en.wikipedia.org/wiki/Array_data_structure
         *
         ** Copyright Notice:
         *  - The list of English words used to create the test data
         *    for this question was derived from the EOWL and UKACD.
         *  - See github.com/imaginate/algorithmIV/blob/master/example/resources/words.json
         *  - See http://dreamsteep.com/projects/the-english-open-word-list.html
         *  - Copyright (c) J Ross Beresford 1993-1999. All Rights Reserved.
         *  - Copyright Details: http://cfajohnson.com/wordfinder/UKACD17.shtml 
         */

        // A hash map of letter to English words
        // An array of all the string's letters and an
        //   indicator of how many duplicates exist
        // A trie of words with a max length of 4
        //   characters and starting with each of
        //   the string's characters
        // The input string
        // The arborescence of the string's characters
        // The resulting possible words from the string
        var words, letters, wordTrie, string, graph, results;

        // Setup variables
        words    = {
          // 'letter': [ 'word', ...]
        };
        letters  = {
          list: [],
          dupl: 0
        }
        wordTrie = {
          // 'current word part': {
          //   isWord: true||false,
          //   value : 'current word part',
          //   kids  : [ reference to child in hash map, ...]
          // }
        };
        string   = 'ogeg';
        graph    = {
          val : '',
          kids: []
        };
        results  = [];

        // Download the json dictionary
        function makeAjaxCall() {
          // Contains the ajax call
          var http;

          http = new XMLHttpRequest();
          http.onreadystatechange = function() {
            // If (ajax finished)
            if (http.readyState === 4 && http.status === 200) {
              // Sanitize and set the words list
              words = JSON.parse(http.responseText);
            }
          };
          http.open('GET', 'resources/words.json', false);
          http.send();
        }

        // Removes string's duplicate letters
        function setLetters() {
          // The loop index
          // The list of letter duplicates
          // The current letter
          var i, duplList, letter;

          // Set duplicate list
          duplList = [];

          // Save letters and duplicates
          for (i=0; i<4; i++) {

            // Save letter
            letter = string.charAt(i);
            // If (no duplicates exist)
            // Then {add letter to list}
            // Else {add letter to duplicates and trigger flag}
            if (letters.list.indexOf(letter) === -1) {
              letters.list.push(letter);
            }
            else {
              duplList.push(letter);
              ++letters.dupl;
            }
          }

          // Sort lists
          letters.list.sort();
          duplList.sort();
          // Append duplicates to main list
          letters.list = letters.list.concat(duplList);
        }

        // Create the trie of words
        function createWordTrie() {
          // The count of unique letters
          // The letter index
          var len, i;

          // Save the letters count
          len = letters.list.length - letters.dupl;
          // Add a branch to the trie for each letter
          for (i=0; i<len; i++) {
            addTrieBranch(letters.list[i]);
          }
        }

        // Adds a branch to the root of trie
        // param: the starting value of the branch
        function addTrieBranch(letter) {
          // The word loop index
          // The count of words
          // The current word
          // The current word length
          // The substring loop index
          // The last character index
          var i, wordsLen, word, wordLen, c, last;
          // The previous word substring
          // The new word substring
          var pNode, child;
          
          // Add branch to trie
          wordTrie[letter] = {
            isWord: false,
             value: letter,
              kids: []
          };
          // Save words length
          wordsLen = words[letter].length;

          // Loop through words
          for (i=0; i<wordsLen; i++) {
            
            // Save word and word length
            word = words[letter][i];
            wordLen = word.length;

            // If (word has less than 5 characters)
            // Then {add word to trie}
            if (wordLen < 5) {

              // If (word is one character)
              // Then {set root end prop to true}
              // Else {add word to trie}
              if (wordLen === 1) {
                wordTrie[letter].isWord = true;
              }
              else {

                // Save last index
                last = wordLen - 1;
                // Save child start
                child = letter;
                // Loop through the word's characters
                for (c=1; c<=last; c++) {

                  // Save current string
                  pNode = child;
                  child += word.charAt(c);

                  // If (child does not exist)
                  // Then {add to trie}
                  // Else {update isWord}
                  if (typeof wordTrie[child] === 'undefined') {
                    wordTrie[child] = {
                      isWord: (c === last),
                       value: child,
                        kids: []
                    };
                    wordTrie[pNode].kids.push(wordTrie[child]);
                  }
                  else {
                    wordTrie[child].isWord = wordTrie[child].isWord || (c === last);
                  }
                }
              }
            }
          }
        }

        // Create arborescence for the supplied string
        function createGraph() {
          // A function to add the letter nodes
          var addKids;

          // Adds each letter's child nodes recursively
          // param: The parent node
          // param: The remaining list
          // param: Indicates whether this is the first pass
          //   and whether list duplicates exist (optional)
          addKids = function(node, list, unique) {
            // The count of the remaining letters
            // The loop index
            // The new substring
            // The child node
            // The newList copy
            var len, i, word, child, copy;

            // Set unique
            unique = unique || false;
            // Set count
            len = list.length - ( (unique) ?
              letters.dupl : 0
            );
            // For each remaining letter
            for (i=0; i<len; i++) {

              // Save new value and child
              word  = node.val + list[i];
              child = { val: word, kids: [] };
              // Add child to parent
              node.kids.push(child);
              // If (remaining letters)
              if (len > 1) {

                // Save modified list
                copy = list.slice(0);
                copy.splice(i, 1);
                // Call recursive function
                addKids(child, copy);
              }
            }
          }

          // Add branches
          addKids(graph, letters.list, !letters.dupl);
        }

        // Finds all of the possible words resulting from the string
        function findWords() {
          // A function to recursively handle the DFS
          var backtrack;

          // Recursively backtrack to find words
          // param: The current node
          backtrack = function(node) {
            // The count of children
            // The loop index
            // The current child
            var len, i, child;

            // Set count
            len = node.kids.length;
            // Loop through children
            for (i=0; i<len; i++) {

              // Set child node
              child = node.kids[i];

              // If (partial word exists)
              // Then {continue search}
              if (!!wordTrie[child.val]) {

                // If (partial word is complete)
                // Then {add word to results}
                if (wordTrie[child.val].isWord &&
                    results.indexOf(child.val) === -1) {
                    results.push(child.val);
                }

                // Continue DFS
                backtrack(child);
              }
            }
          }

          // Start recursive search
          backtrack(graph);
        }

        // Download dictionary, create trie of words,
        //   create arborescence of input string
        //   characters, find the possible words, and
        //   return the results
        makeAjaxCall();
        setLetters();
        createWordTrie();
        createGraph();
        findWords();
        return '[ ' + results.sort().join(',') + ' ]';
      }
    },
    {
      // Question: 5
      complete: true,
        source: 'bl',
       mainCat: [ 'search', 'graph', 'hash', 'list', 'array' ],
        subCat: [ 'dfs', 'brute', 'digraph', 'adjList', 'hTable', 'sList' ],
         links: [
           {
             name: 'Further Discussion',
             href: 'http://www.careercup.com/question?id=5768610725232640'
           }
         ],
       problem: 'Using the below node list find the path that uses all the nodes without duplicating one.<br />' +
                '[ JFK,LXA,SNA,RKJ,LXA,SNA ]<br />' +
                'Note: Each pair of nodes define a directed edge like so:<br />' +
                '[ (JFK -&gt; LXA),(SNA -&gt; RKJ),(LXA -&gt; SNA) ]<br />',
      solution: function() {
        /*
         ** Solution:
         *  - Step 1: A brute force search algorithm is
         *    used to create an arborescence of the nodes
         *    in the vector while simultaneously building
         *    an array containing the two node values
         *    that are not duplicated (i.e. the
         *    possible arborescence roots). A hash table
         *    of nodes forming a singly-linked list is
         *    used to represent the arborescence.
         *  - Step 2: The two possible root node values
         *    are checked, and the root node is saved.
         *  - Step 3: One pass of a DFS algorithm is
         *    used to print the path of the nodes.
         *
         ** Need to Know Terms:
         *  - Algorithms:
         *    -- Brute Force Search: http://en.wikipedia.org/wiki/Brute-force_search
         *    -- Depth First Search (DFS): http://en.wikipedia.org/wiki/Depth-first_search
         *  - Data Structures:
         *    -- Arborescence: http://en.wikipedia.org/wiki/Arborescence_(graph_theory)
         *    -- Directed Graph (Digraph): http://en.wikipedia.org/wiki/Directed_graph
         *    -- Adjacency List: http://en.wikipedia.org/wiki/Adjacency_list
         *    -- Hash Table: http://en.wikipedia.org/wiki/Hash_table
         *    -- Singly-Linked Lists: http://en.wikipedia.org/wiki/Linked_list#Singly_linked_list
         *    -- Linked Lists: http://en.wikipedia.org/wiki/Linked_list
         *    -- Arrays: http://en.wikipedia.org/wiki/Array_data_structure
         */

        // Original node list
        // Arborescence of nodes
        // Possible root nodes
        // Final node path
        var vector, graph, root, result;

        // Set variables
        vector = [ 'JFK','LXA','SNA','RKJ','LXA','SNA' ];
        graph  = {
          // val : 'location name',
          // edge: node reference
        };
        root   = [];
        result = [];

        // Adds unique node keys to the roots list
        //   and removes duplicates
        // param: node value to check
        function addRoot(nodeVal) {
          // Index of node in roots array
          var i;

          // Save node index
          i = root.indexOf(nodeVal);

          // If (node value is not in roots)
          // Then {add to roots}
          // Else {remove from roots}
          if (i === -1) {
            root.push(nodeVal);
          }
          else {
            root.splice(i, 1);
          }

          return (i === -1);
        }

        // Creates an arborescence of the nodes
        function createGraph() {
          // The vector length
          // The loop index
          // The current node value
          // Indicates whether to add new node
          // The vertex node
          // The edge node
          var len, i, val, check, vertex, edge;

          // Save vector length
          len = vector.length;

          // Add nodes
          for (i=0; i<len; i++) {

            // Set and check node value
            val = vector[i];
            check = addRoot(val);
            // If (node value does not exist)
            // Then {add node}
            if (check) {
              graph[val] = {
                val : val,
                edge: null
              }
            }
          }

          // Add edges
          for (i=0; i<len; i++) {

            // Set vertex and edge
            vertex = graph[ vector[i] ];
            edge   = graph[ vector[++i] ];
            // Add edge to vertex
            vertex.edge = edge;
          }
        }

        // Finds the root node
        function findRoot() {
          // The loop index
          // The current node
          var i, node;

          // Loop through roots
          for (i=0; i<2; i++) {

            // Save node reference
            node = graph[ root[i] ];
            // If (node has edge)
            // Then {set root to it}
            if (!!node.edge) {
              root = node;
              return;
            }
          }
        }

        // Finds the resulting path
        function findPath() {
          // The current node
          var node;

          // Set node to root node
          node = root;

          // Run DFS
          while (!!node) {

            // Add current node value to results
            result.push(node.value);
            // If (node has edge)
            // Then {set next node to edge}
            // Else {end loop}
            node = ( (!!node.edge) ?
              node.edge : !node
            );
          }
        }

        // Create arborescence, find root
        //   node, find final path, and
        //   return the result
        createGraph();
        findRoot();
        findPath();
        return result.join(' -&gt; ');
      }
    },
    {
      // Question: 6
      complete: true,
        source: 'go',
       mainCat: [ 'sort', 'tree', 'search', 'list', 'array' ],
        subCat: [ 'heapS', 'binHeap', 'bst', 'back', 'bfs', 'brute', 'sList', 'dList' ],
         links: [
           {
             name: 'More on Converting a Binary Search Tree into a Doubly-Linked List',
             href: 'http://www.careercup.com/question?id=4863668900593664'
           }
         ],
       problem: 'Given an array of random numbers, create a binary search tree with the median as the root. Then convert the binary search tree into a doubly-linked list that is sorted in ascending or descending order and return the first node in the list. Do the sort and conversion in place<span style="margin:0 12px">&ndash;</span>i.e. the memory complexity of your algorithms should be <em style="margin:0 2px">&Omicron;</em>(1).' +
                '<span style="display:block;margin:15px 0 10px">Example diagram of conversion:</span>'  +
                '<style>' +
                  '.aIV-exQ6-table {padding:0;margin:0;text-align:center;border-collapse:collapse;border:0}' +
                  '.aIV-exQ6-table tr {padding:0;margin:0;text-align:center;border:0}' +
                  '.aIV-exQ6-table td {padding:0;margin:0;text-align:center;verticle-align:middle;border:0}' +
                  '.aIV-exQ6-table span.lineContainer {position:relative;display:block;width:100%;height:100%;overflow:hidden}' +
                  '.aIV-exQ6-table span.lineFiller {opacity:0}' +
                  '.aIV-exQ6-table span.topLine {position:absolute;top:2px;left:0;display:block;width:100%;height:1px;background:#192037}' +
                  '.aIV-exQ6-table span.leftLine, .aIV-exQ6-table span.rightLine {position:absolute;top:50%;left:-50%;display:block;width:200%;height:1px;background:#192037}' +
                  '.aIV-exQ6-table span.leftLine {-ms-transform:rotate(-45deg);-moz-transform:rotate(-45deg);webkit-transform:rotate(-45deg);transform:rotate(-45deg)}' +
                  '.aIV-exQ6-table span.rightLine {-ms-transform:rotate(45deg);-moz-transform:rotate(45deg);webkit-transform:rotate(45deg);transform:rotate(45deg)}' +
                '</style>' +
                '<table class="aIV-exQ6-table">' +
                  '<tr>' +
                    '<td><u>Unsorted Array</u></td>' +
                    '<td></td>' +
                    '<td><u>Binary Search Tree</u></td>' +
                    '<td></td>' +
                    '<td><u>Doubly-Linked List</u></td>' +
                  '</tr>' +
                  '<tr>'  +
                    '<td>[&nbsp;&nbsp;7,3,9&nbsp;&nbsp;]</td>' +
                    '<td style="padding:0 20px">&rArr;<br />&rArr;</td>'     +
                    '<td>' +
                      '<table class="aIV-exQ6-table" style="margin:5px auto 0;">' +
                        '<tr>'  +
                          '<td></td>'  +
                          '<td></td>'  +
                          '<td>7</td>' +
                          '<td></td>'  +
                          '<td></td>'  +
                        '</tr>' +
                        '<tr>'  +
                          '<td></td>' +
                          '<td>&sol;</td>'  +
                          '<td></td>' +
                          '<td>&bsol;</td>' +
                          '<td></td>' +
                        '</tr>' +
                        '<tr>'  +
                          '<td>3</td>' +
                          '<td></td>'  +
                          '<td></td>'  +
                          '<td></td>'  +
                          '<td>9</td>' +
                        '</tr>' +
                      '</table>' +
                    '</td>' +
                    '<td style="padding:0 20px">&rArr;<br />&rArr;</td>'     +
                    '<td>3&nbsp;&nbsp;&lrarr;&nbsp;&nbsp;7&nbsp;&nbsp;&lrarr;&nbsp;&nbsp;9</td>' +
                  '</tr>' +
                '</table>',
      solution: function() {
        /*
         ** Solution:
         *  - Step 1: A string of the supplied unsorted
         *    array of values is created for the results.
         *  - Step 2: The array of unsorted values is
         *    sorted to reflect the binary heap property.
         *  - Step 3: The array representing the binary
         *    heap is sorted in ascending order (heapsort).
         *  - Step 4: A balanced binary search tree is
         *    created from the heap. A linked list of
         *    nodes containing their value and references
         *    to their left and right children is used to
         *    represent the binary search tree.
         *  - Step 5: A breadth first search algorithm is
         *    used to create a string of the binary search
         *    tree for the results.
         *  - Step 6: A backtracking algorithm is used to
         *    convert the binary search tree into to a
         *    doubly-linked list.
         *  - Step 7: A brute force search algorithm is
         *    used to create a string of the values in
         *    the doubly-linked list for the results.
         *
         ** Need to Know Terms:
         *  - Algorithms:
         *    -- Heapsort: http://en.wikipedia.org/wiki/Heapsort
         *    -- Breadth First Search (BFS): http://en.wikipedia.org/wiki/Breadth-first_search
         *    -- Backtracking: http://en.wikipedia.org/wiki/Backtracking
         *    -- Brute Force Search: http://en.wikipedia.org/wiki/Brute-force_search
         *  - Data Structures:
         *    -- Binary Heap: http://en.wikipedia.org/wiki/Binary_heap
         *    -- Binary Search Tree: http://en.wikipedia.org/wiki/Binary_search_tree
         *    -- Singly-Linked Lists: http://en.wikipedia.org/wiki/Linked_list#Singly_linked_list
         *    -- Doubly-Linked List: http://en.wikipedia.org/wiki/Doubly_linked_list
         *    -- Linked Lists: http://en.wikipedia.org/wiki/Linked_list
         *    -- Arrays: http://en.wikipedia.org/wiki/Array_data_structure
         */

        // The provided array of random numbers
        // The binary search tree
        // The starting node for the doubly-linked list
        // The final results
        var vals, tree, list, results;

        // Set variables
        vals = [ 88,97,56,41,27,16,95,54,28 ];
        tree = {
          val  : null,
          left : null,
          right: null
        };
        list = {
          val  : null,
          left : null,
          right: null
        };
        results = {
          vals: null,
          tree: null,
          list: null,
          show: ''
        };

        // Sorts the array of random numbers
        function sortValues() {
          // A function to convert the unsorted
          //   array into a heap
          // A function to construct the heap
          // A function to sort the heap
          var createHeap, heapify, sortHeap;

          // Creates a binary heap of the values
          createHeap = function() {
            // The number of provided values
            // The last value's index
            // The current value
            var len, last, val;

            // Save count of values
            len = vals.length;
            // Save last index
            last = len - 1;
            // Save first parent index
            val = (len - 2) / 2;
            val = Math.floor(val);

            // Build heap
            for (; val>=0; val--) {
              heapify(val, last);
            }
          }

          // Ensures the nodes are in heap order
          // param: The index of the starting node
          // param: The index of the ending node
          heapify = function(start, end) {
            // The parent index
            // The left child index
            // The right child index
            // The index of the biggest value
            var prt, left, right, max;

            // Set the first parent and child
            prt  = start;
            left = (prt * 2) + 1;

            // Check each parent node
            while (left <= end) {

              // Set max
              max = (vals[left] > vals[prt]) ? left : prt;

              // Set right child
              right = left + 1;
              // If (right child exists)
              // Then {check max value}
              if (right <= end) {
                max = (vals[right] > vals[max]) ? right : max;
              }

              // If (parent is max)
              // Then {end heapify}
              if (prt === max) {
                return;
              }

              // Swap parent and child values
              vals[max] = ( vals[prt] + (vals[prt] = vals[max]) ) - vals[max];

              // Set new parent and child indexes
              prt  = max;
              left = (prt * 2) + 1;
            }
          }

          // Sorts the heap
          sortHeap = function() {
            // The last index of the heap size
            var i;

            // Set index to the heap's last
            i = vals.length - 1;
            // Sort heap
            while (i > 0) {
            
              // Move the max (root) value to the end of the heap
              vals[i] = ( vals[0] + (vals[0] = vals[i]) ) - vals[i];

              // Reduce the heap size by 1
              --i;

              // Repair the heap missing its root
              heapify(0, i);
            }
          }
          
          // Run heapsort on array of values
          createHeap();
          sortHeap();
        }

        // Creates the binary search tree
        function createTree() {
          // A recursive function to set left children
          // A recursive function to set right children
          // The median heap index
          // The last index of the heap
          var setLeft, setRight, median, last;

          // Sets the left children
          // param: the parent node
          // param: the parent index
          // param: the starting index
          setLeft = function(node, prt, start) {
            // The nodes in the provided range (start to parent)
            // The index of the left child
            // The ending index for a right child
            var nodes, left, end;

            // Find the count of nodes
            nodes = prt - start;

            // If (no nodes)
            // Then {end traversal}
            if (nodes < 1) {
              return;
            }

            // Set the left child index and node
            left = ( (nodes < 3) ?
              prt - 1 : ( (nodes < 5) ?
                prt - 2 : start + Math.ceil(nodes / 2)
              )
            );
            node.left = {
              val  : vals[left],
              left : null,
              right: null
            };

            // If (no next child)
            // Then {end traversal}
            if (nodes === 1) {
              return;
            }

            // Set the next left child
            setLeft(node.left, left, start);

            // If (right child exists)
            // Then {set the right child}
            if (nodes > 2) {
              end = prt - 1;
              setRight(node.left, left, end);
            }
          };

          // Sets the right children
          // param: the parent node
          // param: the parent index
          // param: the ending index
          setRight = function(node, prt, end) {
            // The nodes in the provided range (parent to end)
            // The index of the right child
            // The starting index for a left child
            var nodes, right, start;

            // Find the count of nodes
            nodes = end - prt;

            // If (no nodes)
            // Then {end traversal}
            if (nodes < 1) {
              return;
            }

            // Set the right child index and node
            right = ( (nodes < 3) ?
              prt + 1 : ( (nodes < 6) ?
                prt + 2 : prt + Math.floor(nodes / 2)
              )
            );
            node.right = {
              val  : vals[right],
              left : null,
              right: null
            };

            // If (no next child)
            // Then {end traversal}
            if (nodes === 1) {
              return;
            }

            // Set the next right child
            setRight(node.right, right, end);

            // If (left child exists)
            // Then {set the left child}
            if (nodes > 2) {
              start = prt + 1;
              setLeft(node.right, right, start);
            }
          };

          // Find and set root to median value
          median = vals.length / 2;
          median = Math.floor(median);
          tree.val = vals[median];

          // Set root's left and right children
          setLeft(tree, median, 0);
          last = vals.length - 1;
          setRight(tree, median, last);
        }
        
        // Creates the doubly-linked list
        function createList() {
          // A function that moves the  BST's left root
          //   branch to the doubly-linked list
          // A function that moves the  BST's right root
          //   branch to the doubly-linked list
          var moveLeft, moveRight;

          // Moves the left root branch of the BST to the
          //   doubly-linked list
          moveLeft = function() {
            // The node with the minimum value
            //   remaining in the left branch
            // The min node's parent
            // The last node in the linked list
            var minNode, prtNode, listNode;

            // Set the last node in the linked
            //   list to the beginning
            listNode = list;

            // Find, remove, and replace the min node
            while (!!tree.left) {

              // Set the parent node to the tree root
              prtNode = tree;

              // Find the min node's parent and save both
              while (!!prtNode.left.left) {
                prtNode = prtNode.left;
              }
              minNode = prtNode.left;

              // Remove min node from tree and repair the BST
              prtNode.left = (!minNode.right) ? null : minNode.right;
              minNode.right = null;

              // Add min node to linked list
              listNode.right = minNode;
              minNode.left = listNode;
              listNode = minNode;
            }

            // Add root to linked list
            listNode.right = tree;
            tree.left = listNode;
          };
          
          // Moves the right root branch of the BST to the
          //   doubly-linked list
          moveRight = function() {
            // The node with the maximum value
            //   remaining in the right branch
            // The max node's parent
            // The last node in the linked list
            var maxNode, prtNode, listNode;

            // Set the last node in the linked
            //   list to the end
            listNode = list;

            // Find, remove, and replace the max node
            while (!!tree.right) {

              // Set the parent node to the tree root
              prtNode = tree;

              // Find the max node's parent and save both
              while (!!prtNode.right.right) {
                prtNode = prtNode.right;
              }
              maxNode = prtNode.right;

              // Remove max node from tree and repair the BST
              prtNode.right = (!maxNode.left) ? null : maxNode.left;
              maxNode.left = null;

              // Add max node to linked list
              listNode.left = maxNode;
              maxNode.right = listNode;
              listNode = maxNode;
            }

            // Add root to linked list
            listNode.left = tree;
            tree.right = listNode;
          };

          // Make the doubly-linked list
          moveLeft();
          moveRight();
        }
        
        // Prepares the results for display
        function setResults() {
          // Set final results
          results.show = '' +
          '<span style="display:block;overflow-x:auto">' +
          '<table class="aIV-exQ6-table">' +
            '<tr>' +
              '<td>' +
                '<u>Unsorted Array</u>' +
              '</td>' +
            '</tr>' +
            '<tr>' +
              '<td style="padding:15px 0 0;">' +
                results.vals +
              '</td>' +
            '</tr>' +
            '<tr>' +
              '<td style="padding:15px 0 20px;">' +
                '<span style="margin:0 15px;">&dArr;</span>' +
                '<span style="margin:0 15px;">&dArr;</span>' +
                '<span style="margin:0 15px;">&dArr;</span>' +
              '</td>' +
            '</tr>' +
            '<tr>' +
              '<td>' +
                '<u>Binary Search Tree</u>' +
              '</td>' +
            '</tr>' +
            '<tr>' +
              '<td style="padding:15px 0 0;">' +
                results.tree +
              '</td>' +
            '</tr>' +
            '<tr>' +
              '<td style="padding:15px 0 20px;">' +
                '<span style="margin:0 15px;">&dArr;</span>' +
                '<span style="margin:0 15px;">&dArr;</span>' +
                '<span style="margin:0 15px;">&dArr;</span>' +
              '</td>' +
            '</tr>' +
            '<tr>' +
              '<td>' +
                '<u>Doubly-Linked List</u>' +
              '</td>' +
            '</tr>' +
            '<tr>' +
              '<td style="padding:15px 0;">' +
                results.list +
              '</td>' +
            '</tr>' +
          '</table>' +
          '</span>';
        }

        // Prepares the final string for the unsorted
        //   array to add to the results
        setResults.vals = function() {
          results.vals = '[&nbsp;&nbsp;' + vals.join(',') + '&nbsp;&nbsp;]';
        };

        // Prepares the final string for the binary
        //   search tree to add to the results
        setResults.tree = function() {
          // A function that creates a matrix of the
          //   rows of nodes
          // A function that creates the final string
          var createMatrix, createString;

          // Creates the matrix of nodes for the BST
          createMatrix = function() {
            // The temporary container for the nodes waiting
            //   to be searched
            // The current node being searched
            // The left child
            // The right child
            var row, node, left, right;

            // Set tree results and row properties
            results.tree = [ [tree] ];
            row = {
              now  : [tree],
              next : [],
              isRow: true
            };

            // Loop through BST
            loop:
            while (true) {

              // Set and remove node
              node = row.now.shift();

              // If (node not null)
              // Then {check children}
              left = ( (!node) ?
                null : ( (!node.left) ?
                  null : node.left
                )
              );
              right = ( (!node) ?
                null : ( (!node.right) ?
                  null : node.right
                )
              );
              // Add children to next row
              row.next.push(left, right);
              // If (child exists)
              // Then {remove next row flag}
              row.isRow = row.isRow || (!!left || !!right);

              // If (current row finished)
              // Then {check and set next}
              if (row.now.length === 0) {
                if (row.isRow) {
                  row.now = row.next.slice(0);
                  row.next = [];
                  results.tree.push( row.now.slice(0) );
                  row.isRow = false;
                }
                else {
                  break loop;
                }
              }
            }
          }

          // Creates the final string for the BST
          createString = function() {
            // The final string
            // The number of BST rows
            // The number of BST columns
            // The number of dashes from the root
            // The number of rows more than 3
            // The loop index for rows over three
            // The loop index for the rows
            // The current row
            var string, rows, columns, dashes, over, o, r, row;
            // The number of cells from the edge
            //   to the first node
            // The number of cells between children
            // The number of cells between each branch
            // The index of the last dash
            // The loop index for dashes
            // The number of nodes in the row
            // The last node in row
            // The loop index for the nodes
            // The width of each cell
            var side, gap, mGap, lastD, d, nodes, last, n, width;

            // Set the count of tree items
            rows = results.tree.length;
            dashes = ( (rows < 2) ?
              0 : ( (rows === 2) ?
                1 : 2
              )
            );
            if (rows > 3) {
              over = rows - 3;
              for (o=0; o<over; o++) {
                dashes = (dashes * 2) + 1;
              }
            }
            columns = (rows < 2) ? 1 : (dashes * 4) + 3;
            // Set the last row
            last = rows - 1;
            // Set each cells width
            width = 30;
            // Set the final string
            string = '<table class="aIV-exQ6-table" style="width:' +
            (width * columns) + 'px;margin:0 auto;">';

            // Add table cells for the BST
            for (r=0; r<rows; r++) {

              // Set row, count of nodes in row, and
              //   the index of the last node
              row = results.tree[r];
              nodes = row.length;
              last = nodes - 1;

              // Set the number of empty cells to be
              //   added to the side, the index of
              //   the middle dash, and the gap of
              //   cells between children
              side = ( (r === 0) ?
                Math.floor(columns / 2) : ( (dashes > 1) ?
                  dashes : 0
                )
              );
              gap = (dashes * 2) + 1;
              lastD = (r === 0) ? 0 : dashes - 1;

              // If (not the root row)
              // Then {add a row of dashes to the string}
              if (r > 0) {

                // Open the row
                string += '<tr>' + '<td colspan="' + (side + 1) + '" ' +
                'style="width:' + ( (side + 1) * width) + 'px">&nbsp;</td>';

                // Loop through row nodes
                for (n=0; n<nodes; n++) {

                  // Add dashes for left child
                  if (!!row[n]) {
                    for (d=0; d<dashes; d++) {
                      string += '' +
                      '<td style="width:' + width + 'px">' +
                        '<span class="lineContainer">' +
                          '<span class="lineFiller">&sol;</span>' +
                          ( (d === 0) ?
                            '<span class="leftLine"></span>' :
                            '<span class="topLine"></span>'
                          ) +
                        '</span>' +
                      '</td>';
                    }
                  }
                  else {
                    string += '<td colspan="' + dashes + '" ' +
                    'style="width:' + (dashes * width) + 'px">&nbsp;</td>';
                  }

                  // Add blank cell for parent
                  string += '<td style="width:' + width + 'px">&nbsp;</td>';

                  // Move to the right child
                  ++n;
                  // Add dashes for right child
                  if (!!row[n]) {
                    for (d=0; d<dashes; d++) {
                      string += '' +
                      '<td style="width:' + width + 'px">' +
                        '<span class="lineContainer">' +
                          '<span class="lineFiller">&bsol;</span>' +
                          ( (d === lastD) ?
                            '<span class="rightLine"></span>' :
                            '<span class="topLine"></span>'
                          ) +
                        '</span>' +
                      '</td>';
                    }
                  }
                  else {
                    string += '<td colspan="' + dashes + '" ' +
                    'style="width:' + (dashes * width) + 'px">&nbsp;</td>';
                  }

                  // If (not the last node in row)
                  // Then {add blank space for children and parent's parent}
                  if (n !== last) {
                    string += '<td colspan="' + (mGap + 2) + '" ' +
                    'style="width:' + ((mGap + 2) * width) + 'px">&nbsp;</td>';
                  }
                }

                // Close the row
                string += '<td colspan="' + (side + 1) + '" style="width:' +
                ( (side + 1) * width) + 'px">&nbsp;</td>' + '</tr>';
              }

              // Add a row of nodes to the string
              string += '<tr>' +
              ( (side > 0) ?
                '<td colspan="' + side + '" style="width:' +
                (side * width) + 'px">&nbsp;</td>' : ''
              );

              // If (root)
              // Then {add root node}
              // Else {loop through row nodes}
              if (r === 0) {
                string += '' +
                '<td style="width:' + width + 'px">' +
                  row[0].val +
                '</td>';
              }
              else {
                for (n=0; n<nodes; n++) {

                  // Add left child
                  string += '' +
                  '<td style="width:' + width + 'px">' +
                    ( (!!row[n]) ? row[n].val : '&nbsp;' ) +
                  '</td>';

                  // Add gap cell
                  string += '<td colspan="' + gap + '" style="width:' +
                  (gap * width) + 'px">&nbsp;</td>';

                  // Move to the right child
                  ++n;
                  // Add right child
                  string += '' +
                  '<td style="width:' + width + 'px">' +
                    ( (!!row[n]) ? row[n].val : '&nbsp;' ) +
                  '</td>';

                  // If (not the last node in row)
                  // Then {add blank space for the parent's parent}
                  if (n !== last) {
                    string += '<td colspan="' + mGap + '" style="width:' +
                    (mGap * width) + 'px">&nbsp;</td>';
                  }
                }
              }

              // Close the row
              string += '' +
              ( (side > 0) ?
                '<td colspan="' + side + '" style="width:' +
                (side * width) + 'px">&nbsp;</td>' : ''
              ) + '</tr>';
              
              // Recalculate the mid gap and dashes
              mGap = dashes;
              dashes = ( (r === 0) ?
                dashes : ( (dashes > 2) ?
                  Math.floor(dashes / 2) : 1
                )
              );
              mGap = ( (r === 0) ?
                0 : ( (mGap > 2) ?
                  mGap : 1
                )
              );
            }
            
            // Save results string
            results.tree = string + '</table>';
          }

          // Make the string
          createMatrix();
          createString();
        };

        // Prepares the final string for the
        //   doubly-linked list to add to
        //   the results
        setResults.list = function() {
          // The current node
          var node;

          // Set list results to empty
          results.list = '';
          // Set node to list start
          node = list.right;

          // Add each node value and arrows
          loop:
          while (true) {
            results.list += node.val;
            if (node.right.val === null) {
              break loop;
            }
            results.list += '&nbsp;&nbsp;&lrarr;&nbsp;&nbsp;';
            node = node.right;
          }
        };

        // Sort the values, create the BST,
        //   convert the BST to a list,
        //   and share the results
        setResults.vals();
        sortValues();
        createTree();
        setResults.tree();
        createList();
        setResults.list();
        setResults();
        return results.show;
      }
    },
    {
      // Question: 7
      complete: true,
        source: 'fb',
       mainCat: [ 'search', 'tree', 'list', 'array' ],
        subCat: [ 'bfs', 'binTree', 'sList' ],
         links: [
           {
             name: 'Further Discussion',
             href: 'http://www.careercup.com/question?id=5748231105413120'
           }
         ],
       problem: 'Given a Tree:<br />' +
                '<style>' +
                  '.aIV-exQ7-table {width:' + (35 * 11) + 'px;padding:0;margin:0;text-align:center;border-collapse:collapse;border:0}' +
                  '.aIV-exQ7-table tr {padding:0;margin:0;text-align:center;border:0}' +
                  '.aIV-exQ7-table td {width:35px;padding:0;margin:0;text-align:center;verticle-align:middle;border:0}' +
                  '.aIV-exQ7-table span.lineContainer {position:relative;display:block;width:100%;height:100%;overflow:hidden}' +
                  '.aIV-exQ7-table span.lineFiller {opacity:0}' +
                  '.aIV-exQ7-table span.topLine {position:absolute;top:0;left:0;display:block;width:100%;height:1px;background:#192037}' +
                  '.aIV-exQ7-table span.leftLine, .aIV-exQ7-table span.rightLine {position:absolute;top:50%;left:-50%;display:block;width:200%;height:1px;background:#192037}' +
                  '.aIV-exQ7-table span.leftLine {-ms-transform:rotate(-45deg);-moz-transform:rotate(-45deg);webkit-transform:rotate(-45deg);transform:rotate(-45deg)}' +
                  '.aIV-exQ7-table span.rightLine {-ms-transform:rotate(45deg);-moz-transform:rotate(45deg);webkit-transform:rotate(45deg);transform:rotate(45deg)}' +
                '</style>' +
                '<table class="aIV-exQ7-table">' +
                  '<tr>' +
                    '<td colspan="5">&nbsp;</td>' +
                    '<td>A</td>' +
                    '<td colspan="5">&nbsp;</td>' +
                  '</tr>' +
                  '<tr>' +
                    '<td colspan="3">&nbsp;</td>' +
                    '<td>' +
                      '<span class="lineContainer">' +
                        '<span class="lineFiller">&sol;</span>' +
                        '<span class="leftLine"></span>' +
                      '</span>' +
                    '</td>' +
                    '<td>' +
                      '<span class="lineContainer">' +
                        '<span class="lineFiller">&sol;</span>' +
                        '<span class="topLine"></span>' +
                      '</span>' +
                    '</td>' +
                    '<td>&nbsp;</td>' +
                    '<td>' +
                      '<span class="lineContainer">' +
                        '<span class="lineFiller">&sol;</span>' +
                        '<span class="topLine"></span>' +
                      '</span>' +
                    '</td>' +
                    '<td>' +
                      '<span class="lineContainer">' +
                        '<span class="lineFiller">&sol;</span>' +
                        '<span class="rightLine"></span>' +
                      '</span>' +
                    '</td>' +
                    '<td colspan="3">&nbsp;</td>' +
                  '</tr>' +
                  '<tr>' +
                    '<td colspan="2">&nbsp;</td>' +
                    '<td>B</td>' +
                    '<td colspan="5">&nbsp;</td>' +
                    '<td>C</td>' +
                    '<td colspan="2">&nbsp;</td>' +
                  '</tr>' +
                  '<tr>' +
                    '<td>&nbsp;</td>' +
                    '<td>' +
                      '<span class="lineContainer">' +
                        '<span class="lineFiller">&sol;</span>' +
                        '<span class="leftLine"></span>' +
                      '</span>' +
                    '</td>' +
                    '<td>&nbsp;</td>' +
                    '<td>' +
                      '<span class="lineContainer">' +
                        '<span class="lineFiller">&sol;</span>' +
                        '<span class="rightLine"></span>' +
                      '</span>' +
                    '</td>' +
                    '<td colspan="3">&nbsp;</td>' +
                    '<td>' +
                      '<span class="lineContainer">' +
                        '<span class="lineFiller">&sol;</span>' +
                        '<span class="leftLine"></span>' +
                      '</span>' +
                    '</td>' +
                    '<td>&nbsp;</td>' +
                    '<td>' +
                      '<span class="lineContainer">' +
                        '<span class="lineFiller">&sol;</span>' +
                        '<span class="rightLine"></span>' +
                      '</span>' +
                    '</td>' +
                    '<td>&nbsp;</td>' +
                  '</tr>' +
                  '<tr>' +
                    '<td>D</td>' +
                    '<td colspan="3">&nbsp;</td>' +
                    '<td>E</td>' +
                    '<td>&nbsp;</td>' +
                    '<td>F</td>' +
                    '<td colspan="3">&nbsp;</td>' +
                    '<td>G</td>' +
                  '</tr>' +
                '</table><br />' +
                'Write a function that prints:<br />' +
                'A<br />' +
                'BC<br />' +
                'DEFG',
      solution: function() {
        /*
         ** Solution:
         *  - Step 1: A Breadth First Search algorithm is used
         *    to create a balanced binary tree. A linked list
         *    of nodes containing their value and references
         *    to their left and right children is used to
         *    represent the binary tree.
         *  - Step 2: A Breadth First Search algorithm is used
         *    to traverse the tree and add the nodes in order
         *    by row to the result.
         *
         ** Need to Know Terms:
         *  - Algorithms:
         *    -- Breadth First Search (BFS): http://en.wikipedia.org/wiki/Breadth-first_search
         *  - Data Structures:
         *    -- Binary Tree: http://en.wikipedia.org/wiki/Binary_tree
         *    -- Singly-Linked Lists: http://en.wikipedia.org/wiki/Linked_list#Singly_linked_list
         *    -- Linked Lists: http://en.wikipedia.org/wiki/Linked_list
         *    -- Arrays: http://en.wikipedia.org/wiki/Array_data_structure
         */

        // The given values
        // The binary tree
        // The node rows to be printed
        var vals, tree, result;

        // Set variables
        vals = [ 'A','B','C','D','E','F','G' ];
        tree = {
          val  : vals[0],
          left : null,
          right: null
        };
        result = '';

        // Creates the binary tree
        function createTree() {
          // A function that adds children to a node
          // The temporary holder for each row of nodes
          // The index of the current value
          // The current tree's depth
          // The tree's max depth
          // The current node
          var addNodes, row, val, d, depth, node;

          // Adds children to the provided node
          // param: The node to add the children
          addNodes = function(prtNode) {

            // Create the nodes and increase the value
            prtNode.left = {
              val  : vals[val],
              left : null,
              right: null
            };
            ++val;
            prtNode.right = {
              val  : vals[val],
              left : null,
              right: null
            };
            ++val;

            // Add the nodes to temp holder
            row.next.push(prtNode.left, prtNode.right);
          };

          // Set the temp holders, value, and max depth
          row = {
            now : [tree],
            next: []
          };
          val = 1;
          depth = 3;

          // Add the nodes to tree
          for (d=1; d<depth; d++) {
            // Add nodes
            row.now.forEach(function(node) {
              addNodes(node);
            });
            // Reset temp arrays
            row.now = row.next.slice(0);
            row.next = [];
          }
        }

        // Saves a string of the binary tree's nodes
        //   in order with a line break for each row
        function printNodes() {
          // The current and next row of nodes
          // The current node being searched
          // The left child
          // The right child
          var row, node, left, right;

          // Set final result
          result = tree.val;

          // Set temp holder for each row
          row = {
              now   : [tree],
              next  : [],
              string: ''
            };

          // Loop through nodes
          loop:
          while (true) {

            // Set and remove node
            node = row.now.shift();

            // If (child exists)
            // Then {add child to next row and result}
            if (!!node.left) {
              row.next.push(node.left);
              row.string += node.left.val;
            }
            if (!!node.right) {
              row.next.push(node.right);
              row.string += node.right.val;
            }

            // If (current row finished)
            // Then {check, update, and reset rows}
            // Else {end search}
            if (row.now.length === 0) {
              if (row.next.length > 0) {
                result += '<br />' + row.string;
                row.now = row.next.slice(0);
                row.next = [];
                row.string = '';
              }
              else {
                break loop;
              }
            }
          }
        }

        // Create tree and print nodes
        createTree();
        printNodes();
        return result;
      }
    },
    {
      // Question: 8
      complete: true,
        source: 'go',
       mainCat: [ 'search', 'tree', 'list', 'array' ],
        subCat: [ 'dfs', 'dList' ],
         links: [
           {
             name: 'Further Discussion',
             href: 'http://www.careercup.com/question?id=6295449935806464'
           }
         ],
       problem: 'Represent the following in a data structure:' +
                '<ol style="padding:0;margin:0;list-style-type:none">' +
                  '<li>&lt;html&gt;</li>' +
                  '<li style="padding-left:20px">&lt;body&gt;</li>' +
                  '<li style="padding-left:40px">&lt;div&gt;</li>' +
                  '<li style="padding-left:60px">&lt;span&gt;Lorem Ipsum&lt;/span&gt;</li>' +
                  '<li style="padding-left:60px">&lt;br /&gt;</li>' +
                  '<li style="padding-left:40px">&lt;/div&gt;</li>' +
                  '<li style="padding-left:20px">&lt;/body&gt;</li>' +
                  '<li>&lt;/html&gt;</li>' +
                '</ol>',
      solution: function() {
        /*
         ** Solution:
         *  - Step 1: A doubly-linked list of nodes
         *    containing their tag name, content, and
         *    an array of child node references (in
         *    order by appearance) is created to represent
         *    a plane tree of the DOM elements where the
         *    html tag is the root node.
         *  - Step 2: A depth first search algorithm is
         *    used to add each element to a final result
         *    string.
         *
         ** Need to Know Terms:
         *  - Algorithms:
         *    -- Depth First Search (DFS): http://en.wikipedia.org/wiki/Depth-first_search
         *  - Data Structures:
         *    -- Plane Trees: http://en.wikipedia.org/wiki/Tree_(graph_theory)#Plane_tree
         *    -- Doubly-Linked List: http://en.wikipedia.org/wiki/Doubly_linked_list
         *    -- Linked Lists: http://en.wikipedia.org/wiki/Linked_list
         *    -- Arrays: http://en.wikipedia.org/wiki/Array_data_structure
         */

        // The data structure for the DOM nodes
        // The final string output of the nodes
        var html, result;

        // Set data structures
        html = {
          tag    : 'html',
          _parent: null,
          content: '',
          kids   : []
        };
        result = '';

        // Adds the elements to the html page
        function addElements() {
          // A function that adds an element
          // The current element
          // The span element
          var addElement, elem, span;

          // Adds an element to the page
          // param: The new tag name (string)
          // param: The parent node
          addElement = function(tag, prt) {
            // The new element
            var newElem;

            // Create the new element
            newElem = {
              tag    : tag,
              _parent: prt,
              content: '',
              kids   : []
            };

            // Append it to the parent
            prt.kids.push(newElem);
            
            return newElem;
          };

          // Add nodes to the html tree
          elem = addElement('body', html);
          elem = addElement('div', elem);
          span = addElement('span', elem);
          addElement('br', elem);

          // Add content to nodes
          span.content = 'Lorem Ipsum';
        }

        // Creates a string output of the DOM nodes
        function prepareResult() {
          // A function that adds an element and
          //   its children to the result
          // A function that returns the string
          //   value for an element
          // A function that returns the padding
          //   value for a line
          // The padding amount for each indent
          var addElement, getString, getPadding, padding;

          // Adds an element and its children
          //   to the result
          // param: The element node
          // param: The current depth
          addElement = function(elem, depth) {
            // The number of children
            // The child node
            var kids, kid;

            // Set the count of children
            kids = elem.kids.length;

            // Add the element to the result
            result += '' +
            '<li style="' + getPadding(depth) + '">' +
              getString(elem.tag) +
              ( (kids === 0) ?
                elem.content +
                getString(elem.tag, true) :
                ''
              ) +
            '</li>';

            // If (no children)
            // Then {end addition}
            if (kids === 0) {
              return;
            }

            // Increase the depth
            ++depth;

            // Add the element's content and
            //   children to the result
            result += ( (elem.content !== '') ?
              '<li style="' + getPadding(depth) + '">' +
                elem.content +
              '</li>' :
              ''
            );
            elem.kids.forEach(function(kid) {
              addElement(kid, depth);
            });

            // Decrease the depth
            --depth;

            // Add the element closing tag
            result += '' +
            '<li style="' + getPadding(depth) + '">' +
              getString(elem.tag, true) +
            '</li>';

            return;
          };

          // Returns a string value for the element
          // param: The element's tag name
          // param: Indicates if element is closing (optional)
          getString = function(tag, end) {
            return ( (tag === 'br') ?
              ( (!end) ? '&lt;br /&gt;' : '' ) :
              '&lt;' + ( (!!end) ? '/' : '' ) +
              tag + '&gt;'
            );
          };

          // Returns the padding value for a line
          // param: The current depth
          getPadding = function(depth) {
            return 'padding-left:' +
            (padding * depth) + 'px';
          };

          // Set the padding px amount for each indent
          padding = 20;

          // Set the result
          result = '<ol style="padding:0;margin:0;list-style-type:none">';
          addElement(html, 1);
          result += '</ol>';
        }

        // Create the DOM data structure
        //   and print the elements
        addElements();
        prepareResult();
        return result;
      }
    },
    {
      // Question: 9
      complete: false,
        source: 'am',
       mainCat: [],
        subCat: [],
         links: [
           {
             name: 'Further Discussion',
             href: 'http://www.careercup.com/question?id=5082499984130048'
           }
         ],
       problem: 'Design a data structure that can do the following operations in <em style="margin:0 2px">&Omicron;</em>(1) time:<br />' +
                'Insert, Delete, Search, Return Max',
      solution: function() {
        /*
         ** Overview:
         *  -  
         *
         ** Solution:
         *  - [explanation]
         *
         ** Need to Know Terms:
         *  - Algorithms:
         *    -- [term]: [link]
         *  - Data Structures:
         *    -- [term]: [link]
         */
      }
    },
    {
      // Question: 10
      complete: false,
        source: 'am',
       mainCat: [ 'array' ],
        subCat: [],
         links: [
           {
             name: 'Further Discussion',
             href: 'http://www.careercup.com/question?id=6260358392053760'
           }
         ],
       problem: 'You are given two integer arrays, A and B. Consider the following:<br />' +
                '1 &lt;= x &lt;= len(A) &nbsp;&nbsp;so x is iterator of array A<br />' +
                '1 &lt;= z &lt;= len(B) &nbsp;&nbsp;so z is iterator of array B<br /><br />' +
                'Find all the pairs (x,z) such that : x &lt; z &nbsp;&nbsp;and&nbsp;&nbsp; A[x] &gt; B[z]',
      solution: function() { 
        /*
         ** Solution:
         *  - [explanation]
         *
         ** Need to Know Terms:
         *  - Algorithms:
         *    -- [term]: [link]
         *  - Data Structures:
         *    -- [term]: [link]
         *    -- Arrays: http://en.wikipedia.org/wiki/Array_data_structure
         */
      }
    }
  ];

/* ---------------------------- *
 * -- DO NOT EDIT BELOW HERE -- *
 * ---------------------------- */
(function(s,y,k,w){var r=s||{},u=y||{};k=k||{};w=w||[];r.searchSettings=s.searchSettings||{};r.searchDefaults=s.searchDefaults||{};r.questionFormat=s.questionFormat||{};r.prettyCode=s.prettyCode||{};u.main=y.main||{};u.sub=y.sub||{};"undefined"!==typeof window&&algorithmIV.init(r,u,k,w)})(configuration,categories,sources,questions);
(function(s){onmessage=function(b){b=b.data;y=b.qLen;k=b.configuration;w=b.sources;r=b.categories;u.init();self.postMessage(k.content)};var y,k={},w={},r={},u=function(){var b;return{init:function(){var v;for(v=0;v<y;v++){b={id:{flag:!1,content:""},source:{flag:!1,content:""},complete:{flag:!1,content:""},category:{flag:!1,main:{flag:!1,h3:"",p:""},sub:{flag:!1,h3:"",p:""}},solution:{error:!1,code:"",height:0},output:{flag:!1,content:""},links:{flag:!1,content:[]}};var f=void 0,c=void 0,f=k.questionFormat.id,
c="";f&&(c=v+1,c=10>c?"00"+c:100>c?"0"+c:""+c);b.id.flag=f;b.id.content=c;f=s[v].source;c=void 0;c=0<w.len&&k.questionFormat.source;b.source.flag=c;b.source.content=c?w.list[f]:"";f=s[v].complete;b.complete.flag=k.questionFormat.complete;b.complete.content=k.questionFormat.complete?f?"Yes":"No":"";var f=s[v].mainCat,c=s[v].subCat,l=void 0,u=void 0,z=void 0,t=l=void 0,g=void 0,p=l=void 0,t=void 0,l=r.len.main,t=f.length,g=c.length,l=0<l&&k.questionFormat.category,u=0<t,z=0<g;b.category.flag=l;b.category.main.flag=
u;b.category.sub.flag=z;if(l){if(u)for(b.category.main.h3="Main "+(1<t?"Categories:":"Category:"),l=0;l<t;l++)b.category.main.p+=0===l?"":", ",b.category.main.p+=r.main[f[l]];if(0<g)for(b.category.sub.h3="Sub "+(1<g?"Categories:":"Category:"),l=0;l<g;l++)a:for(p in b.category.sub.p+=0===l?"":", ",r.sub)if(r.sub.hasOwnProperty(p)&&(t=r.sub[p],"string"===typeof t[c[l]])){b.category.sub.p+=t[c[l]];break a}}f=s[v].solution;p=g=c=void 0;c="function"!==typeof f;c||(g=B.init(f),p=g.lineCount*k.prettyCode.liHeight,
p+=k.prettyCode.olHeight);b.solution.error=c;b.solution.code=c?"":g.result;b.solution.height=c?0:p;f=s[v].solution;g=c=void 0;g=(c="function"===typeof f&&k.questionFormat.output)?f():"";g="string"!==typeof g?String(g):g;b.output.flag=c;b.output.content=g;f=s[v].links;p=g=c=void 0;g=f.length;if(c=0<g&&k.questionFormat.links)for(p=0;p<g;p++)b.links.content.push({href:f[p].href,name:f[p].name});else b.links.content=[];b.links.flag=c;k.content.push(b)}}}}(),B=function(){var b,k="([{;*/%+-<>&^|=!".split(""),
f=/[0-9\.]/,c=/[a-f0-9x\.]/i,l=/[a-z_\$]/i,s=/[a-z0-9_\$]/i,r={def:"defKey",res:"resKey",nat:"natKey",val:"valKey",cli:"cliKey",jqu:"jquKey"},t={"-class":{cat:"def",props:null},"-const":{cat:"def",props:null},"-function":{cat:"def",props:null},"-var":{cat:"def",props:null},"-abstract":{cat:"res",props:null},"-arguments":{cat:"res",props:null},"-boolean":{cat:"res",props:null},"-break":{cat:"res",props:null},"-byte":{cat:"res",props:null},"-case":{cat:"res",props:null},"-catch":{cat:"res",props:null},
"-char":{cat:"res",props:null},"-continue":{cat:"res",props:null},"-debugger":{cat:"res",props:null},"-default":{cat:"res",props:null},"-delete":{cat:"res",props:null},"-do":{cat:"res",props:null},"-double":{cat:"res",props:null},"-else":{cat:"res",props:null},"-enum":{cat:"res",props:null},"-export":{cat:"res",props:null},"-extends":{cat:"res",props:null},"-final":{cat:"res",props:null},"-finally":{cat:"res",props:null},"-float":{cat:"res",props:null},"-for":{cat:"res",props:null},"-goto":{cat:"res",
props:null},"-if":{cat:"res",props:null},"-implements":{cat:"res",props:null},"-import":{cat:"res",props:null},"-in":{cat:"res",props:null},"-instanceof":{cat:"res",props:null},"-int":{cat:"res",props:null},"-interface":{cat:"res",props:null},"-item":{cat:"res",props:null},"-let":{cat:"res",props:null},"-long":{cat:"res",props:null},"-native":{cat:"res",props:null},"-new":{cat:"res",props:null},"-package":{cat:"res",props:null},"-private":{cat:"res",props:null},"-protected":{cat:"res",props:null},
"-public":{cat:"res",props:null},"-return":{cat:"res",props:null},"-short":{cat:"res",props:null},"-static":{cat:"res",props:null},"-super":{cat:"res",props:null},"-switch":{cat:"res",props:null},"-synchronized":{cat:"res",props:null},"-this":{cat:"res",props:null},"-throw":{cat:"res",props:null},"-throws":{cat:"res",props:null},"-transient":{cat:"res",props:null},"-try":{cat:"res",props:null},"-typeof":{cat:"res",props:null},"-void":{cat:"res",props:null},"-volatile":{cat:"res",props:null},"-while":{cat:"res",
props:null},"-with":{cat:"res",props:null},"-yield":{cat:"res",props:null},"-apply":{cat:"nat",props:null},"-Array":{cat:"nat",props:{"-from":1,"-isArray":1,"-observe":1,"-of":1}},"-ArrayBuffer":{cat:"nat",props:{"-isView":1,"-transfer":1}},"-bind":{cat:"nat",props:null},"-Boolean":{cat:"nat",props:null},"-call":{cat:"nat",props:null},"-charAt":{cat:"nat",props:null},"-charCodeAt":{cat:"nat",props:null},"-clearInterval":{cat:"nat",props:null},"-clearTimeout":{cat:"nat",props:null},"-concat":{cat:"nat",
props:null},"-constructor":{cat:"nat",props:null},"-DataView":{cat:"nat",props:null},"-Date":{cat:"nat",props:{"-UTC":1,"-now":1,"-parse":1}},"-decodeURI":{cat:"nat",props:null},"-decodeURIComponent":{cat:"nat",props:null},"-encodeURI":{cat:"nat",props:null},"-encodeURIComponent":{cat:"nat",props:null},"-Error":{cat:"nat",props:null},"-escape":{cat:"nat",props:null},"-eval":{cat:"nat",props:null},"-EvalError":{cat:"nat",props:null},"-fromCharCode":{cat:"nat",props:null},"-Function":{cat:"nat",props:null},
"-Generator":{cat:"nat",props:null},"-GeneratorFunction":{cat:"nat",props:null},"-getDate":{cat:"nat",props:null},"-getDay":{cat:"nat",props:null},"-getFullYear":{cat:"nat",props:null},"-getHours":{cat:"nat",props:null},"-getMilliseconds":{cat:"nat",props:null},"-getMinutes":{cat:"nat",props:null},"-getMonth":{cat:"nat",props:null},"-getSeconds":{cat:"nat",props:null},"-getTime":{cat:"nat",props:null},"-getTimezoneOffset":{cat:"nat",props:null},"-getUTCDate":{cat:"nat",props:null},"-getUTCDay":{cat:"nat",
props:null},"-getUTCFullYear":{cat:"nat",props:null},"-getUTCHours":{cat:"nat",props:null},"-getUTCMilliseconds":{cat:"nat",props:null},"-getUTCMinutes":{cat:"nat",props:null},"-getUTCMonth":{cat:"nat",props:null},"-getUTCSeconds":{cat:"nat",props:null},"-getYear":{cat:"nat",props:null},"-hasOwnProperty":{cat:"nat",props:null},"-indexOf":{cat:"nat",props:null},"-isFinite":{cat:"nat",props:null},"-isNaN":{cat:"nat",props:null},"-isPrototypeOf":{cat:"nat",props:null},"-join":{cat:"nat",props:null},
"-JSON":{cat:"nat",props:{"-parse":1,"-stringify":1}},"-lastIndexOf":{cat:"nat",props:null},"-length":{cat:"nat",props:null},"-match":{cat:"nat",props:null},"-Math":{cat:"nat",props:{"-abs":1,"-acos":1,"-asin":1,"-atan":1,"-atan2":1,"-ceil":1,"-cos":1,"-exp":1,"-floor":1,"-log":1,"-max":1,"-min":1,"-pow":1,"-random":1,"-round":1,"-sin":1,"-sqrt":1,"-tan":1}},"-Number":{cat:"nat",props:{"-EPSILON":1,"-isNaN":1,"-isFinite":1,"-isInteger":1,"-isSafeInteger":1,"-MAX_SAFE_INTEGER":1,"-MAX_VALUE":1,"-MIN_SAFE_INTEGER":1,
"-MIN_VALUE":1,"-NaN":1,"-NEGATIVE_INFINITY":1,"-parseFloat":1,"-parseInt":1,"-POSITIVE_INFINITY":1}},"-Object":{cat:"nat",props:{"-assign":1,"-create":1,"-defineProperty":1,"-defineProperties":1,"-freeze":1,"-getOwnPropertyDescriptor":1,"-getOwnPropertyNames":1,"-getOwnPropertySymbols":1,"-getPrototypeOf":1,"-is":1,"-isExtensible":1,"-isFrozen":1,"-isSealed":1,"-keys":1,"-observe":1,"-preventExtensions":1,"-seal":1,"-setPrototypeOf":1}},"-parse":{cat:"nat",props:null},"-parseFloat":{cat:"nat",props:null},
"-parseInt":{cat:"nat",props:null},"-pop":{cat:"nat",props:null},"-preference":{cat:"nat",props:null},"-print":{cat:"nat",props:null},"-prototype":{cat:"nat",props:null},"-push":{cat:"nat",props:null},"-RegExp":{cat:"nat",props:null},"-replace":{cat:"nat",props:null},"-reset":{cat:"nat",props:null},"-resizeBy":{cat:"nat",props:null},"-resizeTo":{cat:"nat",props:null},"-reverse":{cat:"nat",props:null},"-search":{cat:"nat",props:null},"-setDate":{cat:"nat",props:null},"-setFullYear":{cat:"nat",props:null},
"-setHours":{cat:"nat",props:null},"-setMilliseconds":{cat:"nat",props:null},"-setInterval":{cat:"nat",props:null},"-setMinutes":{cat:"nat",props:null},"-setMonth":{cat:"nat",props:null},"-setSeconds":{cat:"nat",props:null},"-setTime":{cat:"nat",props:null},"-setTimeout":{cat:"nat",props:null},"-setUTCDate":{cat:"nat",props:null},"-setUTCFullYear":{cat:"nat",props:null},"-setUTCHours":{cat:"nat",props:null},"-setUTCMilliseconds":{cat:"nat",props:null},"-setUTCMinutes":{cat:"nat",props:null},"-setUTCMonth":{cat:"nat",
props:null},"-setUTCSeconds":{cat:"nat",props:null},"-setYear":{cat:"nat",props:null},"-shift":{cat:"nat",props:null},"-slice":{cat:"nat",props:null},"-sort":{cat:"nat",props:null},"-splice":{cat:"nat",props:null},"-split":{cat:"nat",props:null},"-String":{cat:"nat",props:{"-fromCharCode":1,"-fromCodePoint":1,"-raw":1}},"-substr":{cat:"nat",props:null},"-substring":{cat:"nat",props:null},"-Symbol":{cat:"nat",props:{"-for":1,"-keyFor":1}},"-test":{cat:"nat",props:null},"-toGMTString":{cat:"nat",props:null},
"-toLocaleString":{cat:"nat",props:null},"-toLowerCase":{cat:"nat",props:null},"-toSource":{cat:"nat",props:null},"-toString":{cat:"nat",props:null},"-toUpperCase":{cat:"nat",props:null},"-toUTCString":{cat:"nat",props:null},"-TypedArray":{cat:"nat",props:{"-BYTES_PER_ELEMENT":1,"-from":1,"-name":1,"-of":1}},"-unescape":{cat:"nat",props:null},"-unshift":{cat:"nat",props:null},"-unwatch":{cat:"nat",props:null},"-UTC":{cat:"nat",props:null},"-valueOf":{cat:"nat",props:null},"-watch":{cat:"nat",props:null},
"-write":{cat:"nat",props:null},"-writeln":{cat:"nat",props:null},"-false":{cat:"val",props:null},"-Infinity":{cat:"val",props:null},"-Nan":{cat:"val",props:null},"-null":{cat:"val",props:null},"-true":{cat:"val",props:null},"-undefined":{cat:"val",props:null},"-alert":{cat:"cli",props:null},"-anchor":{cat:"cli",props:null},"-anchors":{cat:"cli",props:null},"-appendChild":{cat:"cli",props:null},"-area":{cat:"cli",props:null},"-assign":{cat:"cli",props:null},"-back":{cat:"cli",props:null},"-big":{cat:"cli",
props:null},"-blink":{cat:"cli",props:null},"-blur":{cat:"cli",props:null},"-body":{cat:"cli",props:null},"-bold":{cat:"cli",props:null},"-button":{cat:"cli",props:null},"-byteToString":{cat:"cli",props:null},"-captureEvents":{cat:"cli",props:null},"-checkbox":{cat:"cli",props:null},"-className":{cat:"cli",props:null},"-click":{cat:"cli",props:null},"-clientHeight":{cat:"cli",props:null},"-clientInformation":{cat:"cli",props:null},"-clientWidth":{cat:"cli",props:null},"-close":{cat:"cli",props:null},
"-closed":{cat:"cli",props:null},"-confirm":{cat:"cli",props:null},"-console":{cat:"cli",props:{"-assert":1,"-group":1,"-groupCollapsed":1,"-groupEnd":1,"-log":1,"-trace":1}},"-createElement":{cat:"cli",props:null},"-crypto":{cat:"cli",props:null},"-defaultStatus":{cat:"cli",props:null},"-disableExternalCapture":{cat:"cli",props:null},"-document":{cat:"cli",props:null},"-element":{cat:"cli",props:null},"-elements":{cat:"cli",props:null},"-embed":{cat:"cli",props:null},"-embeds":{cat:"cli",props:null},
"-enableExternalCapture":{cat:"cli",props:null},"-event":{cat:"cli",props:null},"-fileUpload":{cat:"cli",props:null},"-find":{cat:"cli",props:null},"-fixed":{cat:"cli",props:null},"-focus":{cat:"cli",props:null},"-fontcolor":{cat:"cli",props:null},"-fontsize":{cat:"cli",props:null},"-form":{cat:"cli",props:null},"-forms":{cat:"cli",props:null},"-forward":{cat:"cli",props:null},"-frame":{cat:"cli",props:null},"-frames":{cat:"cli",props:null},"-frameRate":{cat:"cli",props:null},"-getComputedStyle":{cat:"cli",
props:null},"-getElementById":{cat:"cli",props:null},"-getElementsByClassName":{cat:"cli",props:null},"-getElementsByTagName":{cat:"cli",props:null},"-getOptionValueCount":{cat:"cli",props:null},"-getOptionValue":{cat:"cli",props:null},"-getPropertyValue":{cat:"cli",props:null},"-getSelection":{cat:"cli",props:null},"-go":{cat:"cli",props:null},"-handleEvent":{cat:"cli",props:null},"-hidden":{cat:"cli",props:null},"-history":{cat:"cli",props:null},"-home":{cat:"cli",props:null},"-id":{cat:"cli",props:null},
"-image":{cat:"cli",props:null},"-ImageData":{cat:"cli",props:{"-data":1,"-height":1,"-width":1}},"-images":{cat:"cli",props:null},"-innerHeight":{cat:"cli",props:null},"-innerHTML":{cat:"cli",props:null},"-innerWidth":{cat:"cli",props:null},"-italics":{cat:"cli",props:null},"-javaEnabled":{cat:"cli",props:null},"-layer":{cat:"cli",props:null},"-layers":{cat:"cli",props:null},"-link":{cat:"cli",props:null},"-location":{cat:"cli",props:null},"-mimeTypes":{cat:"cli",props:null},"-moveAbove":{cat:"cli",
props:null},"-moveBelow":{cat:"cli",props:null},"-moveBy":{cat:"cli",props:null},"-moveTo":{cat:"cli",props:null},"-moveToAbsolute":{cat:"cli",props:null},"-navigate":{cat:"cli",props:null},"-navigator":{cat:"cli",props:null},"-offscreenBuffering":{cat:"cli",props:null},"-offsetHeight":{cat:"cli",props:null},"-offsetWidth":{cat:"cli",props:null},"-open":{cat:"cli",props:null},"-opener":{cat:"cli",props:null},"-options":{cat:"cli",props:null},"-outerHeight":{cat:"cli",props:null},"-outerWidth":{cat:"cli",
props:null},"-packages":{cat:"cli",props:null},"-pageXOffset":{cat:"cli",props:null},"-pageYOffset":{cat:"cli",props:null},"-parent":{cat:"cli",props:null},"-password":{cat:"cli",props:null},"-pkcs11":{cat:"cli",props:null},"-plugins":{cat:"cli",props:null},"-prompt":{cat:"cli",props:null},"-propertyIsEnum":{cat:"cli",props:null},"-radio":{cat:"cli",props:null},"-refresh":{cat:"cli",props:null},"-releaseEvents":{cat:"cli",props:null},"-reload":{cat:"cli",props:null},"-removeChild":{cat:"cli",props:null},
"-routeEvent":{cat:"cli",props:null},"-screen":{cat:"cli",props:null},"-screenX":{cat:"cli",props:null},"-screenY":{cat:"cli",props:null},"-scroll":{cat:"cli",props:null},"-scrollBy":{cat:"cli",props:null},"-scrollTo":{cat:"cli",props:null},"-secure":{cat:"cli",props:null},"-select":{cat:"cli",props:null},"-self":{cat:"cli",props:null},"-small":{cat:"cli",props:null},"-status":{cat:"cli",props:null},"-stop":{cat:"cli",props:null},"-strike":{cat:"cli",props:null},"-style":{cat:"cli",props:null},"-submit":{cat:"cli",
props:null},"-sup":{cat:"cli",props:null},"-taint":{cat:"cli",props:null},"-taintEnabled":{cat:"cli",props:null},"-text":{cat:"cli",props:null},"-textContent":{cat:"cli",props:null},"-textarea":{cat:"cli",props:null},"-top":{cat:"cli",props:null},"-untaint":{cat:"cli",props:null},"-window":{cat:"cli",props:null},"-$":{cat:"jqu",props:null},"-jQuery":{cat:"jqu",props:null}},g,p=function(){function b(a){switch(e[a]){case ">":d[a]="&gt;";break;case "<":d[a]="&lt;"}}function p(a){for(;;){++a;if(a>=x)return a;
switch(e[a]){case "*":if("/"===e[a+1])return++a;break;case ">":case "<":b(a)}}}function h(a){var d;for(d=e[a];;){++a;if(a===x)return--a;switch(e[a]){case d:if("\\"!==e[a-1])return a;break;case ">":case "<":b(a)}}}function u(a){d[a]='<span class="str">'+e[a];a=h(a);d[a]+="</span>";return a}function m(a){d[a]='<span class="brc">'+e[a]+"</span>";return a}function n(a){d[a]='<span class="opr">'+("<"===e[a]?"&lt;":">"===e[a]?"&gt;":e[a])+"</span>";return a}function A(a){d[a]='<span class="per">.</span>';
return a}function q(a){d[a]='<span class="num">'+e[a];a:{var b;b=e[a]+e[a+1];for(b="0x"===b||"0X"===b?c:f;;){if(a===x-1)break a;if(!b.test(e[a+1]))break a;++a}}d[a]+="</span>";return a}function w(a,b){var c,g,h,f;a:for(h=a,g="-";;){g+=e[h];if(h===x-1){c=h;h=void 0;break a}if(!s.test(e[h+1])){c=h;h="."===e[h+1];break a}++h}t[g]&&(f=t[g].cat,f=r[f],"-function"===g&&("("===e[c+1]||" "===e[c+1]&&"("===e[c+2])&&(f=r.res));!f&&b&&t[b].props[g]&&(f=t[b].cat,f=r[f]);d[a]='<span class="'+(f||"idt")+'">'+e[a];
d[c]+="</span>";a=c;h&&(A(++a),b=t[g]?t[g].props?g:void 0:void 0,a=w(++a,b));return a}var d,e,x,y={"'":function(a){return u(a)},'"':function(a){return u(a)}," ":function(a){d[a]='<span class="spc"> ';a:for(;;){if(" "!==e[a+1])break a;++a}d[a]+="</span>";return a},"{":function(a){return m(a)},"[":function(a){return m(a)},"(":function(a){return m(a)},")":function(a){return m(a)},"]":function(a){return m(a)},"}":function(a){return m(a)},"*":function(a){return n(a)},"%":function(a){return n(a)},"+":function(a){return n(a)},
"-":function(a){return n(a)},"<":function(a){return n(a)},">":function(a){return n(a)},"&":function(a){return n(a)},"^":function(a){return n(a)},"|":function(a){return n(a)},"=":function(a){return n(a)},"!":function(a){return n(a)},"~":function(a){return n(a)},"?":function(a){return n(a)},",":function(a){d[a]='<span class="cmm">,</span>';return a},";":function(a){d[a]='<span class="smc">;</span>';return a},":":function(a){d[a]='<span class="cln">:</span>';return a},".":function(a){return A(a)},0:function(a){return q(a)},
1:function(a){return q(a)},2:function(a){return q(a)},3:function(a){return q(a)},4:function(a){return q(a)},5:function(a){return q(a)},6:function(a){return q(a)},7:function(a){return q(a)},8:function(a){return q(a)},9:function(a){return q(a)},"/":function(a){switch(e[a+1]){case "/":return d[a]='<span class="cmt">/',a=x-1,d[a]+="</span>",a;case "*":return d[a]='<span class="cmt">/',a=p(++a),a===x&&(g=!0,--a),d[a]+="</span>",a;default:if(-1!==k.indexOf(0===a?"(":" "===e[a-1]?e[a-2]:e[a-1])){var b;d[a]=
'<span class="rgx">/';a=h(a);b=[];a:for(;;){if(3===b.length)break a;switch(e[a+1]){case "g":case "i":case "m":if(-1!==b.indexOf(e[a+1]))break a;b.push(e[a+1]);++a;break;default:break a}}d[a]+="</span>";return a}return n(a)}}};return{init:function(a){e=a.split("");x=e.length;d=e.slice();a:{a=0;if(g&&(d[a]="*"===e[a]?" ":"",d[a]+='<span class="cmt">'+e[a],"*"===e[0]&&"/"===e[1]?(g=!1,d[1]+="</span>",a=3):(a=p(a),a<x?(g=!1,d[a]+="</span>",++a):d[a-1]+="</span>"),a===x)){a=d.join("");break a}for(;a<x;a++)y[e[a]]?
a=y[e[a]](a):l.test(e[a])?a=w(a):d[a]='<span class="msc">'+e[a]+"</span>";a=d.join("")}return a}}}();return{init:function(c){c=String(c).replace(/\r\n?/g,"\n").replace(/\t/g," ").split("\n");var f,h,l;b=0;g=!1;l=c.length;for(f=0;f<c.length;f++){h=c[f];var m=void 0,n=void 0,k=void 0,q=void 0;h=h.split("");n=h.length;k=n-1;q={code:"",first:"",last:"",padding:0,empty:!1};m=0;a:for(;m<n;m++){if(" "===h[m])h[m]="";else{q.first=h[m];break a}m===k&&(q.empty=!0)}if(!q.empty)a:for(m=k;0<=m;m--)if(" "===h[m])h[m]=
"";else{q.last=h[m];break a}q.code=h.join("");h=q;if(!h.empty){m=h;n=h.last;k=void 0;switch(h.first){case "}":case "]":case ")":--b}k=20*b;switch(n){case "{":case "[":case "(":case "?":++b}m.padding=k}h.empty||(h.code=p.init(h.code));c[f]='<li style="padding-left:'+h.padding+'px">'+h.code+"</li>"}return{result:c.join(""),lineCount:l}}}}()})(questions);}());
