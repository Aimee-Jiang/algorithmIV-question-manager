/* Algorithm IV (v1.0.0) (learn@algorithmiv.com)
 * Section: User Data, App Initialization, & Web Worker
 * Author: Adam Smith (adamsmith@youlum.com)
 * Copyright (c) 2015 Adam A Smith (github.com/imaginate)
 * The MIT License (algorithmiv.com/docs/license) */

/**
 * ------------------------------------------------------------------
 * Algorithm IV User Data (v1.0.0)
 * ------------------------------------------------------------------
 * manages a list of practice questions and detailed solutions
    for learning computer science focused algorithms and data
    structures, improving programming skillsets, and preparing
    for technical interviews
 * settings: configuration, categories, sources, and questions
 * directions:
   - see algorithmiv.com/docs/start
 */
(function() {
  "use strict";

  /**
   * -----------------------------------------------
   * Public Variable (configuration)
   * -----------------------------------------------
   * an object containing the configuration settings
      for this module
   * details:
     - see algorithmiv.com/docs/configuration
   */
  var configuration = {
    searchSettings: {
         stage: true,
        source: true,
      category: true,
        subCat: true
    },
    searchDefaults: {
         view: 'one',
        order: 'asc',
        stage: 'all',
       source: 'all',
      mainCat: 'all',
       subCat: 'all',
      startID: 0
    },
    questionFormat: {
            id: true,
      complete: true,
        source: true,
      category: true,
         links: true,
        output: true
    },
    prettyCode: {
      lineHeight: 26
    },
        id: true,
    worker: true
  };

  /**
   * -----------------------------------------------
   * Public Variable (sources)
   * -----------------------------------------------
   * an object containing all of the problem sources
   * details:
     - see algorithmiv.com/docs/sources
   */
  var sources = {
    'am': 'Amazon',
    'bl': 'Bloomberg',
    'fb': 'Facebook',
    'go': 'Google'
  };

  /**
   * -----------------------------------------------
   * Public Variable (categories)
   * -----------------------------------------------
   * an object containing each main and sub question
     category
   * details:
     - see algorithmiv.com/docs/categories
   */
  var categories = {
    main: {
      'array' : 'Arrays',
      'graph' : 'Graphs',
      'hash'  : 'Hashes',
      'list'  : 'Linked Lists',
      'search': 'Searching Algorithms',
      'sort'  : 'Sorting Algorithms',
      'tree'  : 'Trees'
    },
    sub: {
      'graph': {
        'adjList': 'Adjacency Lists',
        'adjMtrx': 'Adjacency Matrices',
        'digraph': 'Directed Graphs',
        'incList': 'Incidence Lists',
        'incMtrx': 'Incidence Matrices',
        'ungraph': 'Undirected Graphs'
      },
      'hash': {
        'dblHash': 'Double Hashing',
        'fnv'    : 'FNV Hash Algorithms',
        'hTable' : 'Hash Tables'
      },
      'list': {
        'sList': 'Singly-Linked Lists',
        'dList': 'Doubly-Linked Lists'
      },
      'search': {
        'back'   : 'Backtracking',
        'binSrch': 'Binary Search',
        'bfs'    : 'Breadth First Search',
        'brute'  : 'Brute Force Search',
        'dfs'    : 'Depth First Search',
        'dynam'  : 'Dynamic Programming'
      },
      'sort': {
        'bucket': 'Bucket Sort',
        'heapS' : 'Heapsort',
        'insert': 'Insertion Sort',
        'merge' : 'Mergesort',
        'quick' : 'Quicksort',
        'radix' : 'Radix Sort',
        'select': 'Select Sort'
      },
      'tree': {
        'binHeap': 'Binary Heaps',
        'binTree': 'Binary Trees',
        'bst'    : 'Binary Search Trees',
        'bnmHeap': 'Binomial Heaps',
        'fibHeap': 'Fibonacci Heaps',
        'red'    : 'Red-Black Trees',
        'splay'  : 'Splay Trees',
        'trie'   : 'Tries'
      }
    }
  };

  /**
   * ---------------------------------------------
   * Public Variable (questions)
   * ---------------------------------------------
   * an array of objects containing each question,
      its details, and your solution for it
   * details:
     - see algorithmiv.com/docs/questions
   */
  var questions = [
    {
      // Question: 1
      complete: true,
        source: 'fb',
       mainCat: [ 'search', 'tree', 'array' ],
        subCat: [ 'bfs', 'binTree' ],
         links: [
           {
             name: 'Further Discussion',
             href: 'http://www.careercup.com/question?id=4505011482525696'
           }
         ],
       problem: 'Write a function that prints the rows of a binary tree, terminating each row with a carriage return.',
      solution: function() {
        /*
         ** Solution:
         *  - Step 1: A binary tree is created. An array of
         *    nodes storing their value and a reference to
         *    their children is used to implement the tree.
         *  - Step 2: A Breadth First Search algorithm is used
         *    to traverse the tree and add the nodes in order
         *    by row to the result.
         *
         ** Need to Know Terms:
         *  - Algorithms:
         *    -- Breadth First Search (BFS): http://en.wikipedia.org/wiki/Breadth-first_search
         *  - Data Structures:
         *    -- Binary Tree: http://en.wikipedia.org/wiki/Binary_tree
         *    -- Arrays: http://en.wikipedia.org/wiki/Array_data_structure
         */

        // The binary tree
        // The node rows to be printed
        var tree, result;

        // Set variables
        tree = [];
        result = '';

        // Creates the binary tree
        function createTree() {
          // Node index
          // Edge index
          var n, e;

          // Add empty nodes to tree
          for (n=0; n<15; n++) {
              tree.push({ val: n, edges: [] });
          }

          // Set edge index
          e = 1;
          // Add edges to tree
          for (n=0; n<7; n++) {
            tree[n].edges.push(tree[e],tree[e+1]);
            e += 2;
          }
        }

        // Saves a string of the binary tree's nodes
        //   in order with a line break for each row
        function printNodes() {
          // The list of current nodes to be searched
          // The current node being searched
          // The max nodes possible in the current row
          // The count of nodes in the current row
          // The count of the node's edges
          // The edges index
          var list, node, rowMax, rowCount, edges, e;

          // Set list to array with tree root
          list = [ tree[0] ];
          // Set max of first row
          rowMax = 1;
          // Set current row count
          rowCount = 0;

          // Loop through nodes
          while (list.length > 0) {

            // Set node and remove first item
            node = list.shift();
            // Increase the count by one
            ++rowCount;
            // Set result
            result += node.val + ( (rowMax === rowCount) ? '<br />' : ',' );

            // If (row finished)
            // Then {double max and reset count}
            if (rowMax === rowCount) {
              rowMax = rowMax * 2;
              rowCount = 0;
            }

            // Save node's edge count
            edges = node.edges.length;
            // Add node's edges to list
            for (e=0; e<edges; e++) {
              list.push(node.edges[e]);
            }
          }
        }
        
        // Create tree and print nodes
        createTree();
        printNodes();
        return result;
      }
    },
    {
      // Question: 2
      complete: true,
        source: 'am',
       mainCat: [ 'search', 'graph', 'array' ],
        subCat: [ 'back', 'dynam', 'dfs', 'digraph', 'incList' ],
         links: [
           {
             name: 'Further Discussion',
             href: 'http://www.careercup.com/question?id=6031402409656320'
           }
         ],
       problem: 'Imagine a large city like Los Angeles. Suppose someone shows up at location A, then N minutes later at location B. Design a function that approximates the probability they passed a Starbucks.',
      solution: function() {
        /*
         ** Solution:
         *  - Step 1: A time weighted digraph of locations
         *    and a boolean value for whether a Starbucks is
         *    passed for each edge is created. An array of
         *    vertex nodes (storing its value and a reference
         *    to each of its edges) and edge nodes (storing
         *    its weight, Starbuck's value, and a reference
         *    to each of its connecting nodes) is used to
         *    implement the digraph.
         *  - Step 2: A recursive dynamic backtracking DFS
         *    algorithm is applied to traverse the digraph
         *    and find all of the paths possible to the
         *    destination within the provided maximum time
         *    frame and whether a Starbucks was passed on
         *    each path.
         *  - Step 3: The probability of passing a Starbucks
         *    is calculated.
         *
         ** Need to Know Terms:
         *  - Algorithms:
         *    -- Backtracking: http://en.wikipedia.org/wiki/Backtracking
         *    -- Dynamic Programming: http://en.wikipedia.org/wiki/Dynamic_programming
         *    -- Depth First Search (DFS): http://en.wikipedia.org/wiki/Depth-first_search
         *  - Data Structures:
         *    -- Directed Graph (Digraph): http://en.wikipedia.org/wiki/Directed_graph
         *    -- Weighted Graph: http://en.wikipedia.org/wiki/Glossary_of_graph_theory#Weighted_graphs_and_networks
         *    -- Incidence List: http://www.algorithmist.com/index.php/Graph_data_structures#Incidence_List
         *    -- Arrays: http://en.wikipedia.org/wiki/Array_data_structure
         */

        // The time weighted digraph
        // The starting vertex (starting location)
        // The final vertex (final destination)
        // The maximum weight of a path (minutes of time)
        // The final paths
        // The probability of passing a Starbucks
        // The visually prepared final results
        var graph, start, end, max, paths, prob, results;

        // Set variables
        graph = {
          vertices: [],
          edges: []
        };
        start =  0;
        end   =  9;
        max   = 50;
        paths = {
          list: [],
          starbucks: 0
        };
        prob  = 0;
        results = {
          count: {
            all: '',
            starbucks: ''
          },
          prob: '',
          paths: {
            all: '',
            starbucks: ''
          }
        };

        // Creates the weighted digraph
        function createGraph() {
          // The vertex index
          // The edge index
          // The edge's parent vertex
          // The edge's child vertex
          // The edge's weight
          // The edge's Starbuck's value
          var v, e, parent, child, weight, starbucks;
          // The parent index
          // The child index
          // A shortcut function to add edge
          //   pointers to vertices
          var p, c, addPointer;
          
          // Set shortcut function
          // param: The vertex's index
          // param: An array of the edge's indexes
          addPointer = function(vertex, edges) {
            // The number of edges
            // The loop index
            // The edge node
            var len, i, node;
            
            // Save edges count
            len = edges.length;
            // Add each edge
            for (i=0; i<len; i++) {
              node = graph.edges[ edges[i] ];
              graph.vertices[vertex].edges.push(node);
            }
          }

          // Add vertices to graph
          for (v=0; v<10; v++) {
            graph.vertices.push({ val: v, edges: [] });
          }

          // Add edges to graph
          for (e=0; e<16; e++) {

            // Set weight and starbucks
            weight = 5;
            starbucks = (e === 5) ? true : false;
            // Set parent and child
            switch (true) {
              case (e < 3):
                p = 0;
                c = (e === 0) ? 1 : ++c;
                parent = graph.vertices[p];
                child  = graph.vertices[c];
              break;
              case (e < 5):
                p = 1;
                c = e;
                parent = graph.vertices[p];
                child  = graph.vertices[c];
              break;
              case (e < 7):
                p = 2;
                c = e;
                parent = graph.vertices[p];
                child  = graph.vertices[c];
              break;
              case (e === 7):
                p = 3;
                c = 6;
                parent = graph.vertices[p];
                child  = graph.vertices[c];
              break;
              case (e === 8):
                p = 4;
                c = 6;
                parent = graph.vertices[p];
                child  = graph.vertices[c];
              break;
              case (e < 12):
                p = 5;
                c = ++c;
                parent = graph.vertices[p];
                child  = graph.vertices[c];
              break;
              case (e < 14):
                p = 6;
                c = (e === 12) ? 7 : 9;
                parent = graph.vertices[p];
                child  = graph.vertices[c];
              break;
              case (e === 14):
                p = 7;
                c = 8;
                parent = graph.vertices[p];
                child  = graph.vertices[c];
              break;
              case (e === 15):
                p = 8;
                c = 9;
                parent = graph.vertices[p];
                child  = graph.vertices[c];
              break;
            }
            // Add edge
            graph.edges.push({
              parent: parent,
              child : child,
              weight: weight,
              starbucks: starbucks
            });
          }

          // Add edge pointers to vertices
          addPointer(0, [ 0,1,2 ]);
          addPointer(1, [ 3,4 ]);
          addPointer(2, [ 5,6 ]);
          addPointer(3, [ 7 ]);
          addPointer(4, [ 8 ]);
          addPointer(5, [ 9,10,11 ]);
          addPointer(6, [ 12,13 ]);
          addPointer(7, [ 14 ]);
          addPointer(8, [ 15 ]);
        }

        // Finds all of the paths possible
        //   within the max time
        function findPaths() {
          // The path being currently reviewed
          // A function that is called recursively
          //   to find each path
          var path, buildPaths;

          // Set the recursive DFS
          // param: The current node
          // param: The current cumulative weight
          // param: Whether a starbucks currently exists
          buildPaths = function(node, weight, starbucks) {
            // The string for the current path
            // The count of the node's edges
            // The edges index
            // The current edge's node
            // The new total path weight
            // The new starbucks value
            var edges, e, edge, newWeight, newStarbucks;

            // If (weight is greater than max weight)
            // Then {end this path traversal}
            if (weight > max) {
              return;
            }

            // If (node is destination)
            // Then {add path to results and end traversal}
            if (node.val === end) {

              // Save string of path
              path.string = '[ ' +
                path.values.join(',') + ',' + end +
              ' ]';

              // Add path to final list of paths
              paths.list.push({
                val: path.string,
                starbucks: starbucks
              });
              // Adjust count of Starbucks paths
              paths.starbucks += (starbucks) ? 1 : 0;

              // End this path traversal
              return;
            }

            // Add node to current path
            path.nodes.push(node);
            path.values.push(node.val);

            // Save the node's count of edges
            edges = node.edges.length;
            // Traverse each path rooting with each edge
            for (e=0; e<edges; e++) {
              // Save reference of edge's object
              edge = node.edges[e];
              // Set new weight total
              newWeight = weight + edge.weight;
              // Set new value for starbucks
              newStarbucks = (starbucks || edge.starbucks);
              // Continue search
              buildPaths(edge.child, newWeight, newStarbucks);
            }

            // Remove current node from path
            path.nodes.pop();
            path.values.pop();
          }

          // Set path to empty
          path = {
            nodes : [],
            values: [],
            string: ''
          };
          // Find the paths
          buildPaths(graph.vertices[start], 0, false);
        }

        // Calculates the probability of passing a Starbucks
        function calcProbability() {
          // Divide the number of paths with starbucks
          //   by the number of all paths and round up
          //   to the nearest whole percent
          prob = (paths.starbucks / paths.list.length) * 100;
          prob = Math.ceil(prob);
        }

        // Prepares an output for visual appeal
        function prepareResults() {
          // The count of paths
          // The first Starbucks path flag
          // The loop index
          var len, flag, i;

          // Save count of paths
          len = paths.list.length;
          
          // Set count results
          results.count.all = 'Count of All Paths: ' + len + '<br />';
          results.count.starbucks  = 'Count of All Paths with Starbucks: ';
          results.count.starbucks += paths.starbucks + '<br />';

          // Set probability result
          results.prob = 'Probability of Passing Starbucks: ' + prob + '%<br />';

          // Set path result headers
          results.paths.all = 'List of All Paths:';
          results.paths.starbucks = 'List of All Paths with Starbucks:';
          // Set path result containers
          results.paths.all += '<span style="display:block;margin-left:30px">';
          results.paths.starbucks += '<span style="display:block;margin-left:30px">';
          // Set first Starbucks flag
          flag = true;
          // Set path results
          for (i=0; i<len; i++) {
            results.paths.all += (i > 0) ? '<br />' : '';
            results.paths.all += paths.list[i].val;
            if (paths.list[i].starbucks) {
              // If (first path with Starbucks)
              // Then {change flag}
              // Else {add line break}
              if (flag) {
                flag = false;
              }
              else {
                results.paths.starbucks += '<br />';
              }
              results.paths.starbucks += paths.list[i].val;
            }
          }
          // Close path result containers
          results.paths.all += '</span>';
          results.paths.starbucks += '</span>';
        }

        // Create digraph, find paths,
        //   calculate probability, and
        //   return the prepared results
        createGraph();
        findPaths();
        calcProbability();
        prepareResults();
        return results.count.all + results.count.starbucks +
        results.prob + results.paths.all + results.paths.starbucks;
      }
    },
    {
      // Question: 3
      complete: true,
        source: 'go',
       mainCat: [ 'hash', 'search' ],
        subCat: [ 'hTable', 'dblHash', 'fnv', 'brute' ],
         links: [
           {
             name: 'Further Discussion',
             href: 'http://www.careercup.com/question?id=5724911848914944'
           }
         ],
       problem: 'Given a table of [Url =&gt; Content] pairs produce a new table of [Url =&gt; Duplicate Urls] pairs.<br /><br />' +
                'Example Input:<br />' +
                'a.com =&gt; &lt;html&gt;alpha&lt;/html&gt;<br />' +
                'b.com =&gt; &lt;html&gt;beta&lt;/html&gt;<br />' +
                'c.com =&gt; &lt;html&gt;gamma&lt;/html&gt;<br />' +
                'd.com =&gt; &lt;html&gt;alpha&lt;/html&gt;<br />' +
                'e.com =&gt; &lt;html&gt;alpha&lt;/html&gt;<br /><br />' +
                'Example Output:<br />' +
                'a.com =&gt; [ d.com, e.com ]<br />' +
                'b.com =&gt; []<br />' +
                'c.com =&gt; []',
      solution: function() {
        /*
         ** Solution:
         *  - Step 1: A hash table using the original
         *    urls as the keys and their page's content
         *    as the values is created.
         *  - Step 2: A hash table using a 32 bit hash
         *    of the page's content for each key and the
         *    content itself as the value is created. A
         *    modified FNV-1a hash algorithm is used to
         *    hash the content. After each new hash
         *    creation the original hash table is
         *    modified (i.e. the content is replaced
         *    with its hash).
         *  - Step 3: An optimized brute force algorithm
         *    is applied to visit each url and identify
         *    any urls with the duplicate content until
         *    all urls have been marked as unique or
         *    duplicated.
         *
         ** Need to Know Terms:
         *  - Algorithms:
         *    -- FNV Hash Algorithm: http://www.isthe.com/chongo/tech/comp/fnv/
         *    -- Double Hashing: http://en.wikipedia.org/wiki/Double_hashing
         *    -- Brute Force Search: http://en.wikipedia.org/wiki/Brute-force_search
         *  - Data Structures:
         *    -- Hash Table: http://en.wikipedia.org/wiki/Hash_table
         */
        
        // The supplied urls and their page's content
        // The hash table of all page's content
        // The list of urls and their duplicated content
        // The visually prepared duplicate results
        var inputs, hashes, duplicates, results;

        // Set variables
        inputs = {};
        hashes = {};
        duplicates = {};
        results = [];

        // Adds the original list of urls
        function setupInputs() {
          // Add urls to inputs
          inputs['a.com'] = '<html>alpha</html>';
          inputs['b.com'] = '<html>beta</html>';
          inputs['c.com'] = '<html>gamma</html>';
          inputs['d.com'] = '<html>alpha</html>';
          inputs['e.com'] = '<html>alpha</html>';
        }

        // Hashes a string with the FNV-1a hash algorithm
        // param: The string to be hashed
        // param: The hashed collision
        // param: The extra rotations to resolve a collision
        function createHash(string, hash, extras) {
          // The FNV offset basis for the hash
          // The FNV prime number to use for multiplication
          // The string length
          // The loop index
          var offset, prime, len, i;

          // Set offset and prime to the 32 bit FNV values
          offset = 2166136261;
          prime  = 16777619;

          // If (no hash supplied)
          // Then {create new hash}
          // Else {resolve collision}
          if (typeof hash === 'undefined') {

            // Offset the hash
            hash = offset;

            // Save string length
            len = string.length;
            // Loop through each string character
            for (i=0; i<len; i++) {
              // XOR and multiply by prime
              hash = hash ^ string.charAt(i);
              hash = hash * prime;
            }
          }
          else {

            // Loop through each extra time
            for (i=0; i<extras; i++) {
              // XOR and multiply by prime
              hash = hash ^ string.charAt(i);
              hash = hash * prime;
            }
          }

          return hash;
        }

        // Creates a hash table for the url page's content
        function createHashTable() {
          // Function that adds hash to table
          // The current url
          // The current url's content
          // The current content's hash
          // Indicator to check if collision has occurred
          var addHash, url, content, hash, flag;

          // Set addHash function
          addHash = function(theUrl, theContent, theHash) {

            // If (hash does not exist in table)
            if (typeof hashes[theHash] === 'undefined') {
              // Add hash key to table
              hashes[theHash] = {
                collisions: 0,
                content: theContent
              };
              // Replace inputs content with hash
              inputs[theUrl] = theHash;
            }
            else {
              // If (no collision)
              // Then {replace inputs content with hash}
              // Else {add collision, create new hash, and repeat process}
              if (theContent === hashes[theHash].content) {
                inputs[theUrl] = theHash;
              }
              else {
                ++hashes[theHash].collisions;
                theHash = createHash(theContent, theHash, hashes[theHash].collisions);
                addHash(theUrl, theContent, theHash);
              }
            }
          }

          // Loop through supplied inputs
          for (url in inputs) {
            // Filter out default javascript properties
            if ( inputs.hasOwnProperty(url) ) {

              // Save, hash, and add the content and 
              //   hash to the hash table
              content = inputs[url];
              hash = createHash(content);
              addHash(url, content, hash);
            }
          }
        }

        // Finds the duplicated url page's content
        function findDuplicates() {
          // The list of the urls to check
          // The current url
          // The current length of the url list
          // The loop index
          // The next url
          // The loop count
          var urls, url, len, i, next, l;

          // Set the url list to empty then
          //   add all the urls to it
          urls = [];
          for (url in inputs) {
            if ( inputs.hasOwnProperty(url) ) {
              urls.push(url);
            }
          }

          // Loop through url list
          while (urls.length > 0) {

            // Save and remove first url on list
            url = urls.shift();
            // Add a property to the duplicates
            //   object with the url as the key
            duplicates[url] = [];

            // Save the current url list length
            len = urls.length;
            // Set index and loop count to 0
            i = l = 0;
            // Loop through url list
            for (; l<len; l++) {

              // Save the next url
              next = urls[i];

              // If (urls content matches)
              // Then {save to duplicates and remove from url list}
              // Else {increase index}
              if (inputs[url] === inputs[next]) {
                duplicates[url].push(next);
                urls.splice(i, 1);
              }
              else {
                ++i;
              }
            }
          }
        }

        // Prepares the results to be returned
        function prepareResults() {
          // The current url
          var url;

          // Add each url to the results array
          for (url in duplicates) {
            if ( duplicates.hasOwnProperty(url) ) {
              results.push(url + ' => [ ' + duplicates[url].join(',') + ' ]');
            }
          }
        }

        // Setup data structures, find duplicated
        //   content, and return visually
        //   prepared results
        setupInputs();
        createHashTable();
        findDuplicates();
        prepareResults();
        return results.join('<br />');
      }
    },
    {
      // Question: 4
      complete: true,
        source: 'go',
       mainCat: [ 'search', 'tree', 'graph', 'hash', 'array' ],
        subCat: [ 'brute', 'back', 'dfs', 'trie', 'digraph', 'adjList', 'hTable' ],
         links: [
           {
             name: 'Further Discussion',
             href: 'http://www.careercup.com/question?id=6270813198090240'
           }
         ],
       problem: 'You are given a string of four lower case characters and a dictionary of english words. Choose a data structure to represent the dictionary and write an algorithm that returns all the words from the dictionary that can be formed by the characters of the string.<br />' +
                'Example:<br />' +
                'string = \'ogeg\'<br />' +
                'words = [ \'egg\',\'ego\', ... ]',
      solution: function() {
        /*
         ** Solution:
         *  - Step 1: A json dictionary of English words is
         *    downloaded for use via ajax.
         *  - Step 2: A brute force algorithm is used to
         *    create a trie of only the words from the
         *    dictionary that have a max of 4 characters
         *    and begin with a letter from the given string.
         *    A hash table with the key set to the current
         *    substring and the value set to a node
         *    containing a boolean value for whether the
         *    substring is a word, the string value of the
         *    substring, and an array of references to its
         *    child nodes is used to represent the trie.
         *  - Step 3: An arborescence is constructed for all
         *    of the characters in the supplied string.
         *  - Step 4: A backtracking algorithm is used to
         *    find all of the possible words resulting from
         *    the arborescence of the supplied string.
         *
         ** Need to Know Terms:
         *  - Algorithms:
         *    -- Brute Force Search: http://en.wikipedia.org/wiki/Brute-force_search
         *    -- Backtracking: http://en.wikipedia.org/wiki/Backtracking
         *    -- Depth First Search (DFS): http://en.wikipedia.org/wiki/Depth-first_search
         *  - Data Structures:
         *    -- Trie: http://www.geeksforgeeks.org/trie-insert-and-search/
         *    -- Arborescence: http://en.wikipedia.org/wiki/Arborescence_(graph_theory)
         *    -- Directed Graph (Digraph): http://en.wikipedia.org/wiki/Directed_graph
         *    -- Adjacency List: http://en.wikipedia.org/wiki/Adjacency_list
         *    -- Hash Table: http://en.wikipedia.org/wiki/Hash_table
         *    -- Arrays: http://en.wikipedia.org/wiki/Array_data_structure
         *
         ** Copyright Notice:
         *  - The list of English words used to create the test data
         *    for this question was derived from the EOWL and UKACD.
         *  - See github.com/imaginate/algorithmIV/blob/master/example/resources/words.json
         *  - See http://dreamsteep.com/projects/the-english-open-word-list.html
         *  - Copyright (c) J Ross Beresford 1993-1999. All Rights Reserved.
         *  - Copyright Details: http://cfajohnson.com/wordfinder/UKACD17.shtml 
         */

        // A list of English words for this test
        // An array of all the string's letters and an
        //   indicator of how many duplicates exist
        // A trie of words with a max length of 4
        //   characters and starting with each of
        //   the string's characters
        // The input string
        // The arborescence of the string's characters
        // The resulting possible words from the string
        var words, letters, wordTrie, string, graph, results;

        // Setup variables
        words    = {};
        letters  = {
          list: [],
          dupl: 0
        }
        wordTrie = {};
        string   = 'ogeg';
        graph    = {};
        results  = [];

        // Download the json dictionary
        function makeAjaxCall() {
          // Contains the ajax call
          var http;

          http = new XMLHttpRequest();
          http.onreadystatechange = function() {
            // If (ajax finished)
            if (http.readyState === 4 && http.status === 200) {
              // Sanitize and set the words list
              words = JSON.parse(http.responseText);
            }
          };
          http.open('GET', 'resources/words.json', false);
          http.send();
        }

        // Removes string's duplicate letters
        function setLetters() {
          // The loop index
          // The list of letter duplicates
          // The current letter
          var i, duplList, letter;

          // Set duplicate list
          duplList = [];

          // Save letters and duplicates
          for (i=0; i<4; i++) {

            // Save letter
            letter = string.charAt(i);
            // If (no duplicates exist)
            // Then {add letter to list}
            // Else {add letter to duplicates and trigger flag}
            if (letters.list.indexOf(letter) === -1) {
              letters.list.push(letter);
            }
            else {
              duplList.push(letter);
              ++letters.dupl;
            }
          }

          // Sort lists
          letters.list.sort();
          duplList.sort();
          // Append duplicates to main list
          letters.list = letters.list.concat(duplList);
        }

        // Create the trie of words
        function createWordTrie() {
          // The count of unique letters
          // The letter index
          var len, i;

          // Save the letters count
          len = letters.list.length - letters.dupl;
          // Add a branch to the trie for each letter
          for (i=0; i<len; i++) {
            addTrieBranch(letters.list[i]);
          }
        }

        // Adds a branch to the root of trie
        // param: the starting value of the branch
        function addTrieBranch(letter) {
          // The word loop index
          // The count of words
          // The current word
          // The current word length
          // The substring loop index
          // The last character index
          var i, wordsLen, word, wordLen, c, last;
          // The previous word substring
          // The new word substring
          var parent, child;
          
          // Add branch to trie
          wordTrie[letter] = {
            isWord: false,
             value: letter,
              kids: []
          };
          // Save words length
          wordsLen = words[letter].length;

          // Loop through words
          for (i=0; i<wordsLen; i++) {
            
            // Save word and word length
            word = words[letter][i];
            wordLen = word.length;

            // If (word has less than 5 characters)
            // Then {add word to trie}
            if (wordLen < 5) {

              // If (word is one character)
              // Then {set root end prop to true}
              // Else {add word to trie}
              if (wordLen === 1) {
                wordTrie[letter].isWord = true;
              }
              else {

                // Save last index
                last = wordLen - 1;
                // Save child start
                child = letter;
                // Loop through the word's characters
                for (c=1; c<=last; c++) {

                  // Save current string
                  parent = child;
                  child += word.charAt(c);

                  // If (child does not exist)
                  // Then {add to trie}
                  // Else {update isWord}
                  if (typeof wordTrie[child] === 'undefined') {
                    wordTrie[child] = {
                      isWord: (c === last),
                       value: child,
                        kids: []
                    };
                    wordTrie[parent].kids.push(wordTrie[child]);
                  }
                  else {
                    wordTrie[child].isWord = wordTrie[child].isWord || (c === last);
                  }
                }
              }
            }
          }
        }

        // Create arborescence for the supplied string
        function createGraph() {
          // A function to add the letter nodes
          var addKids;

          // Adds each letter's child nodes recursively
          // param: The parent node
          // param: The remaining list
          // param: Indicates whether this is the first pass
          //   and whether list duplicates exist (optional)
          addKids = function(node, list, unique) {
            // The count of the remaining letters
            // The loop index
            // The new substring
            // The child node
            // The newList copy
            var len, i, word, child, copy;

            // Set unique
            unique = unique || false;
            // Set count
            len = list.length - ( (unique) ?
              letters.dupl : 0
            );
            // For each remaining letter
            for (i=0; i<len; i++) {

              // Save new value and child
              word  = node.val + list[i];
              child = { val: word, kids: [] };
              // Add child to parent
              node.kids.push(child);
              // If (remaining letters)
              if (len > 1) {

                // Save modified list
                copy = list.slice(0);
                copy.splice(i, 1);
                // Call recursive function
                addKids(child, copy);
              }
            }
          }

          // Setup graph base
          graph = { val: '', kids: [] };
          // Add branches
          addKids(graph, letters.list, !letters.dupl);
        }

        // Finds all of the possible words resulting from the string
        function findWords() {
          // A function to recursively handle the DFS
          var backtrack;

          // Recursively backtrack to find words
          // param: The current node
          backtrack = function(node) {
            // The count of children
            // The loop index
            // The current child
            var len, i, child;

            // Set count
            len = node.kids.length;
            // Loop through children
            for (i=0; i<len; i++) {

              // Set child node
              child = node.kids[i];

              // If (partial word exists)
              // Then {continue search}
              if (!!wordTrie[child.val]) {

                // If (partial word is complete)
                // Then {add word to results}
                if (wordTrie[child.val].isWord &&
                    results.indexOf(child.val) === -1) {
                    results.push(child.val);
                }

                // Continue DFS
                backtrack(child);
              }
            }
          }

          // Start recursive search
          backtrack(graph);
        }

        // Download dictionary, create trie of words,
        //   create arborescence of input string
        //   characters, find the possible words, and
        //   return the results
        makeAjaxCall();
        setLetters();
        createWordTrie();
        createGraph();
        findWords();
        return '[ ' + results.sort().join(',') + ' ]';
      }
    },
    {
      // Question: 5
      complete: true,
        source: 'bl',
       mainCat: [ 'search', 'graph', 'hash', 'array' ],
        subCat: [ 'dfs', 'brute', 'digraph', 'adjList', 'hTable' ],
         links: [
           {
             name: 'Further Discussion',
             href: 'http://www.careercup.com/question?id=5768610725232640'
           }
         ],
       problem: 'Using the below node list find the path that uses all the nodes without duplicating one.<br />' +
                '[ JFK,LXA,SNA,RKJ,LXA,SNA ]<br />' +
                'Note: Each pair of nodes define a directed edge like so:<br />' +
                '[ (JFK -&gt; LXA),(SNA -&gt; RKJ),(LXA -&gt; SNA) ]<br />',
      solution: function() {
        /*
         ** Solution:
         *  - Step 1: A brute force search algorithm is
         *    used to create an arborescence of the nodes
         *    in a vector while simultaneously building
         *    an array containing the two node values
         *    that are not duplicated (i.e. the
         *    possible arborescence roots). A hash
         *    table with a key set to the location
         *    string and a value set to a node
         *    containing the location string and edge
         *    references is used to represent the
         *    arborescence.
         *  - Step 2: The two possible root node
         *    values are checked, and the node value
         *    that is not the root is removed from the
         *    array.
         *  - Step 3: One pass of a DFS algorithm is
         *    used to print the path of the nodes.
         *
         ** Need to Know Terms:
         *  - Algorithms:
         *    -- Brute Force Search: http://en.wikipedia.org/wiki/Brute-force_search
         *    -- Depth First Search (DFS): http://en.wikipedia.org/wiki/Depth-first_search
         *  - Data Structures:
         *    -- Arborescence: http://en.wikipedia.org/wiki/Arborescence_(graph_theory)
         *    -- Directed Graph (Digraph): http://en.wikipedia.org/wiki/Directed_graph
         *    -- Adjacency List: http://en.wikipedia.org/wiki/Adjacency_list
         *    -- Hash Table: http://en.wikipedia.org/wiki/Hash_table
         *    -- Arrays: http://en.wikipedia.org/wiki/Array_data_structure
         */

        // Original node list
        // Arborescence of nodes
        // Possible root nodes
        // Final node path
        var vector, graph, roots, result;

        // Set variables
        vector = [ 'JFK','LXA','SNA','RKJ','LXA','SNA' ];
        graph  = {};
        roots  = [];
        result = [];

        // Adds unique node keys to the roots list
        //   and removes duplicates
        // param: node value to check
        function addRoot(nodeVal) {
          // Index of node in roots array
          var i;

          // Save node index
          i = roots.indexOf(nodeVal);

          // If (node value is not in roots)
          // Then {add to roots}
          // Else {remove from roots}
          if (i === -1) {
            roots.push(nodeVal);
          }
          else {
            roots.splice(i, 1);
          }

          return (i === -1);
        }

        // Creates an arborescence of the nodes
        function createGraph() {
          // The vector length
          // The loop index
          // The current node value
          // Indicates whether to add new node
          // The vertex node
          // The edge node
          var len, i, nodeVal, check, vertex, edge;

          // Save vector length
          len = vector.length;

          // Add nodes
          for (i=0; i<len; i++) {

            // Set and check node value
            nodeVal = vector[i];
            check   = addRoot(nodeVal);
            // If (node value does not exist)
            // Then {add node}
            if (check) {
              graph[nodeVal] = {
                value: nodeVal,
                edges: []
              }
            }
          }

          // Add edges
          for (i=0; i<len; i++) {

            // Set vertex and edge
            vertex = graph[ vector[i] ];
            edge   = graph[ vector[++i] ];
            // Add edge to vertex
            vertex.edges.push(edge);
          }
        }

        // Finds the root node
        function findRoot() {
          // The loop index
          // The current node
          var i, node;

          // Loop through roots
          for (i=0; i<2; i++) {

            // Save node reference
            node = graph[ roots[i] ];
            // If (node does not have an edge)
            // Then {remove it from roots}
            if (node.edges.length === 0) {
              roots.splice(i, 1);
            }
          }
        }

        // Finds the resulting path
        function findPath() {
          // The current node
          // The count of edges
          var node, edges;

          // Set node to root node
          node = graph[ roots[0] ];

          // Run DFS
          while (!!node) {

            // Add current node value to results
            result.push(node.value);
            // Save count of edges
            edges = node.edges.length;
            // If (node has edge)
            // Then {set next node to edge}
            // Else {end loop}
            node = ( (edges > 0) ?
              node.edges[0] : !node
            );
          }
        }

        // Create arborescence, find root
        //   node, find final path, and
        //   return the result
        createGraph();
        findRoot();
        findPath();
        return result.join(' -&gt; ');
      }
    },
    {
      // Question: 6
      complete: false,
        source: 'go',
       mainCat: [ 'sort', 'tree', 'list', 'array' ],
        subCat: [ 'heapS', 'brute', 'binHeap', 'bst', 'dlist' ],
         links: [
           {
             name: 'Further Discussion',
             href: 'http://www.careercup.com/question?id=4863668900593664'
           }
         ],
       problem: '<span style="display:block;margin:0 0 15px">Write a method that will convert a binary search tree into a doubly-linked list that is sorted in ascending or descending order and returns the first node in the list. Do the conversion in place<span style="margin:0 12px">&ndash;</span>i.e. the memory complexity of your algorithm should be <em style="margin:0 2px">&Omicron;</em>(1).</span>' +
                '<span style="display:block;margin:0 0 10px">Provided Node class:</span>' +
                '<span style="word-spacing:6px">public class Node &lbrace;</span><br />'  +
                '<span style="margin-left:25px;word-spacing:6px">public Node left, right;</span><br />' +
                '<span style="margin-left:25px;word-spacing:6px">public String val;</span><br />'       +
                '&rbrace;<br />' +
                '<span style="display:block;margin:15px 0 10px">Example diagram of conversion:</span>'  +
                '<style>' +
                  '.aIV-exQ3-table {padding:0;margin:0;text-align:center;border:0}' +
                  '.aIV-exQ3-table td {padding:0;margin:0;text-align:center}'       +
                '</style>' +
                '<table class="aIV-exQ3-table">' +
                  '<tr>' +
                    '<td><u>Binary Search Tree</u></td>' +
                    '<td></td>' +
                    '<td><u>Doubly-Linked List</u></td>' +
                  '</tr>' +
                  '<tr>'  +
                    '<td>G</td>' +
                    '<td></td>'  +
                    '<td></td>'  +
                  '</tr>' +
                  '<tr>'  +
                    '<td>&sol;&nbsp;&nbsp;&nbsp;&bsol;</td>' +
                    '<td style="padding:0 20px">to</td>'     +
                    '<td>A&nbsp;&nbsp;&rArr;&nbsp;&nbsp;G&nbsp;&nbsp;&rArr;&nbsp;&nbsp;T</td>' +
                  '</tr>' +
                  '<tr>'  +
                    '<td>A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T</td>' +
                    '<td></td>' +
                    '<td></td>' +
                  '</tr>' +
                '</table>',
      solution: function() {
        /*
         ** Solution:
         *  - [explanation]
         *
         ** Need to Know Terms:
         *  - Algorithms:
         *    -- Heapsort: http://en.wikipedia.org/wiki/Heapsort
         *    -- Brute Force Search: http://en.wikipedia.org/wiki/Brute-force_search
         *  - Data Structures:
         *    -- Binary Heap: http://en.wikipedia.org/wiki/Binary_heap
         *    -- Binary Search Tree: http://en.wikipedia.org/wiki/Binary_search_tree
         *    -- Doubly-Linked List: http://en.wikipedia.org/wiki/Doubly_linked_list
         *    -- Arrays: http://en.wikipedia.org/wiki/Array_data_structure
         */

        // A provided array of node values
        // A binary heap of the nodes
        // The binary search tree
        // The starting node for the doubly-linked list
        // The final results
        var vals, heap, tree, list, results;

        // Set variables
        vals = [ 88,97,56,41,27,16,95,54,28 ];
        heap = [];
        tree = [];
        list = {
          prev: null,
          val : null,
          next: null
        };
        results = {
          bst  : [],
          list : [],
          first: ''
        };

        // Creates a binary heap of the values
        function createHeap() {
          // The number of provided values
          // The last value's index
          // The current parent node
          var len, last, parent;

          // Copy unsorted values
          heap = vals.slice(0);
          // Save count of values
          len  = heap.length;
          // Save last index
          last = len - 1;
          // Save first parent index
          parent = (len - 2) / 2;
          parent = Math.floor(parent);

          // Build heap
          for (; parent>=0; parent--) {
            heapify(parent, last);
          }
        }

        // Ensures the nodes are in heap order
        // param: The index of the starting node
        // param: The index of the ending node
        function heapify(start, end) {
          // The parent index
          // The left child index
          // The right child index
          // The index and node of the biggest node
          var p, l, r, parent, left, right, max;

          // Set the first parent and child
          parent = start;
          left = (parent * 2) + 1;
          // Set max to empty
          max = { i: 0, val: 0 };

          // Check each parent node
          while (left <= end) {

            // Set max node index and value
            max.i = (heap[left] > heap[parent]) ? left : parent;
            max.val = heap[max.i];

            // Set right child
            right = left + 1;
            // If (right child exists)
            // Then {check max value}
            if (right <= end) {
              if (heap[right] > max.val) {
                max.i = right;
                max.val = heap[right];
              }
            }

            // If (parent is max)
            // Then {end heapify}
            if (parent === max.i) {
              return;
            }

            // Swap node values
            heap[max.i]  = heap[parent];
            heap[parent] = max.val;

            // Set new parent and child
            parent = max.i;
            left = (parent * 2) + 1;
          }
        }

        // Sorts the heap
        function sortHeap() {
          // The current index
          var i;

          // Set index to the heap's last
          i = heap.length - 1;
          // Sort heap
          while (i > 0) {
            
            // Swap values
            heap[i] = ( heap[0] + (heap[0] = heap[i]) ) - heap[i];
            // Decrease index
            --i;
            // Build heap
            heapify(0, i);
          }
        }

        // Creates the binary search tree
        function createTree() {
          // The loop index
          var i;

          // Add node values to tree
          for (i=0; i<9; i++) {
            tree.push({
              val  : vals[i],
              left : null,
              right: null
            });
          }

          // Add children to tree
          for (i=0; i<9; i++) {
            //tree[i].left = 
            //tree[i].right = 
          }
        }

        // Sets the demo root node
        function findRoot() {
          // The median heap value
          // The root index
          var median, root;

          // Find median
          median = heap.length / 2;
          median = Math.floor(median);
          median = heap[median];
          // Find root
          root = vals.indexOf(median);
          // Move root to beginning of array
          vals.unshift(vals[root]);
          vals.splice(++root, 1);
        }
        
        // Creates the doubly-linked list
        function createList() {
        }
        
        // Sets the first node in the list
        function prepareResults() {
        }

        // Create and sort heap, create BST,
        //   convert BST, and share results
        createHeap();
        sortHeap();
        //createTree();
        //createList();
        //prepareResults();
        //return ;
      }
    },
    {
      // Question: 7
      complete: false,
        source: 'fb',
       mainCat: [],
        subCat: [],
         links: [
           {
             name: 'Further Discussion',
             href: 'http://www.careercup.com/question?id=5748231105413120'
           }
         ],
       problem: 'Given a Tree:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\<br />&nbsp;&nbsp;&nbsp;B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C<br />&nbsp;&nbsp;/ \\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/ \\<br />D&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;&nbsp;F&nbsp;&nbsp;&nbsp;G<br /><br />Write a function that prints:<br />A<br />BC<br />DEFG',
      solution: function() {
        /*
         ** Solution:
         *  - [explanation]
         *
         ** Need to Know Terms:
         *  - Algorithms:
         *    -- [term]: [link]
         *  - Data Structures:
         *    -- [term]: [link]
         */
      }
    },
    {
      // Question: 8
      complete: false,
        source: 'go',
       mainCat: [],
        subCat: [],
         links: [
           {
             name: 'Further Discussion',
             href: 'http://www.careercup.com/question?id=6295449935806464'
           }
         ],
       problem: 'Represent the following in a data structure:<br />&lt;html&gt;&lt;body&gt;&lt;div&gt;&lt;span&gt;TEXT1&lt;/span&gt;&lt;br/&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;<br /><br />Do I do the same using a stack or create a tree for the same?',
      solution: function() {
        /*
         ** Solution:
         *  - [explanation]
         *
         ** Need to Know Terms:
         *  - Algorithms:
         *    -- [term]: [link]
         *  - Data Structures:
         *    -- [term]: [link]
         */
      }
    },
    {
      // Question: 9
      complete: false,
        source: 'am',
       mainCat: [],
        subCat: [],
         links: [
           {
             name: 'Further Discussion',
             href: 'http://www.careercup.com/question?id=5082499984130048'
           }
         ],
       problem: 'Design a data structure that can do the following operations in O(1) time:<br />Insert, Delete, Search, Max (returns the maximum number)<br /><br />I know delete, search and insert can be done O(1) time in a hashmap with a proper hash function, but not sure Max is even possible in O(1) with the presence of delete operation?',
      solution: function() {
        /*
         ** Solution:
         *  - [explanation]
         *
         ** Need to Know Terms:
         *  - Algorithms:
         *    -- [term]: [link]
         *  - Data Structures:
         *    -- [term]: [link]
         */
      }
    },
    {
      // Question: 10
      complete: false,
        source: 'am',
       mainCat: [],
        subCat: [],
         links: [
           {
             name: 'Further Discussion',
             href: 'http://www.careercup.com/question?id=6260358392053760'
           }
         ],
       problem: 'You are given two integer arrays A and B.<br /><br />1&lt;=i&lt;=len(A) so i is iterator of array A<br />1&lt;=j&lt;=len(B) so j is iterator of array B<br /><br />Find all the pairs (i,j) such that : i &lt; j and A[i]&gt;B[j].',
      solution: function() { 
        /*
         ** Solution:
         *  - [explanation]
         *
         ** Need to Know Terms:
         *  - Algorithms:
         *    -- [term]: [link]
         *  - Data Structures:
         *    -- [term]: [link]
         */
      }
    }
  ];

/* ---------------------------- *
 * -- DO NOT EDIT BELOW HERE -- *
 * ---------------------------- */
(function(m,q,l,v){var n=m||{},r=q||{};l=l||{};v=v||[];n.searchSettings=m.searchSettings||{};n.searchDefaults=m.searchDefaults||{};n.questionFormat=m.questionFormat||{};n.prettyCode=m.prettyCode||{};n.prettyCode.prePadding=m.prettyCode.prePadding||{};r.main=q.main||{};r.sub=q.sub||{};"undefined"!==typeof window&&algorithmIV.init(n,r,l,v)})(configuration,categories,sources,questions);
(function(m){onmessage=function(b){b=b.data;q=b.qLen;l=b.configuration;v=b.sources;n=b.categories;r.init();self.postMessage(l.content)};var q,l={},v={},n={},r=function(){var b;return{init:function(){var s;for(s=0;s<q;s++){b={id:{flag:!1,content:""},source:{flag:!1,content:""},complete:{flag:!1,content:""},category:{flag:!1,main:{flag:!1,h3:"",p:""},sub:{flag:!1,h3:"",p:""}},solution:{error:!1,code:"",height:0},output:{flag:!1,content:""},links:{flag:!1,content:[]}};var f=void 0,e=void 0,f=l.questionFormat.id,
e="";f&&(e=s+1,e=10>e?"00"+e:100>e?"0"+e:""+e);b.id.flag=f;b.id.content=e;f=m[s].source;e=void 0;e=0<v.len&&l.questionFormat.source;b.source.flag=e;b.source.content=e?v.list[f]:"";f=m[s].complete;b.complete.flag=l.questionFormat.complete;b.complete.content=l.questionFormat.complete?f?"Yes":"No":"";var f=m[s].mainCat,e=m[s].subCat,g=void 0,r=void 0,y=void 0,t=g=void 0,h=void 0,p=g=void 0,t=void 0,g=n.len.main,t=f.length,h=e.length,g=0<g&&l.questionFormat.category,r=0<t,y=0<h;b.category.flag=g;b.category.main.flag=
r;b.category.sub.flag=y;if(g){if(r)for(b.category.main.h3="Main "+(1<t?"Categories:":"Category:"),g=0;g<t;g++)b.category.main.p+=0===g?"":", ",b.category.main.p+=n.main[f[g]];if(0<h)for(b.category.sub.h3="Sub "+(1<h?"Categories:":"Category:"),g=0;g<h;g++)a:for(p in b.category.sub.p+=0===g?"":", ",n.sub)if(n.sub.hasOwnProperty(p)&&(t=n.sub[p],"string"===typeof t[e[g]])){b.category.sub.p+=t[e[g]];break a}}f=m[s].solution;p=h=e=void 0;e="function"!==typeof f;e||(h=w.init(f),p=h.lineCount*l.prettyCode.lineHeight+
l.prettyCode.prePadding.top+l.prettyCode.prePadding.bottom);b.solution.error=e;b.solution.code=e?"":h.result;b.solution.height=e?0:p;f=m[s].solution;h=e=void 0;h=(e="function"===typeof f&&l.questionFormat.output)?f():"";h="string"!==typeof h?String(h):h;b.output.flag=e;b.output.content=h;f=m[s].links;p=h=e=void 0;h=f.length;if(e=0<h&&l.questionFormat.links)for(p=0;p<h;p++)b.links.content.push({href:f[p].href,name:f[p].name});else b.links.content=[];b.links.flag=e;l.content.push(b)}}}}(),w=function(){var b,
l="([{;*/%+-<>&^|=!".split(""),f=/[0-9\.]/,e=/[a-f0-9x\.]/i,g=/[a-z_\$]/i,m=/[a-z0-9_\$]/i,n=["class","const","function","var"],t="abstract arguments boolean break byte case catch char const continue debugger default delete do double else enum export extends final finally float for goto if implements import in instanceof int interface item let long native new package private protected public return short static super switch synchronized this throw throws transient try typeof void volatile while with yield".split(" "),
h="abs acos Array asin atan atan2 Boolean ceil charAt charCodeAt clearInterval clearTimeout concat cos Date decodeURI decodeURIComponent encodeURI encodeURIComponent escape eval exp floor fromCharCode getDate getDay getFullYear getHours getMilliseconds getMinutes getMonth getSeconds getSelection getTime getTimezoneOffset getUTCDate getUTCDay getUTCFullYear getUTCHours getUTCMilliseconds getUTCMinutes getUTCMonth getUTCSeconds getYear hasOwnProperty Image indexOf isArray isFinite isNaN isPrototypeOf join lastIndexOf length match Math max min Number Object parse parseFloat parseInt pop pow preference print prototype push random RegExp replace reset resizeBy resizeTo reverse round search select setDate setFullYear setHours setMilliseconds setInterval setMinutes setMonth setSeconds setTime setTimeout setUTCDate setUTCFullYear setUTCHours setUTCMilliseconds setUTCMinutes setUTCMonth setUTCSeconds setYear shift sin slice sort splice split sqrt String substr substring tan test toGMTString toLocaleString toLowerCase toSource toString toUpperCase toUTCString unescape unshift unwatch UTC valueOf watch write writeln".split(" "),
p="false Infinity Nan null true undefined".split(" "),r="alert all anchor anchors appendChild area assert assign back big blink blur body bold button byteToString captureEvents checkbox className clearInterval clearTimeout click clientInformation close closed confirm console constructor createElement crypto decodeURI decodeURIComponent defaultStatus disableExternalCapture document element elements embed embeds enableExternalCapture encodeURI encodeURIComponent escape event fileUpload find fixed focus fontcolor fontsize form forms forward frame frames frameRate getElementById getElementsByClassName getElementsByTagName getOptionValueCount getOptionValue go group groupCollapsed groupEnd handleEvent hidden history home id image images innerHeight innerHTML innerWidth italics javaEnabled layer layers link location log mimeTypes moveAbove moveBelow moveBy moveTo moveToAbsolute navigate navigator offscreenBuffering open opener options outerHeight outerWidth packages pageXOffset pageYOffset parent password pkcs11 plugins prompt propertyIsEnum radio refresh releaseEvents reload reset routeEvent screen screenX screenY scroll scrollBy scrollTo secure select self small status stop strike submit sup taint taintEnabled text textContent textarea top trace unescape untaint window".split(" "),
v=["$","jQuery"],q,w=function(){function b(a){switch(d[a]){case ">":c[a]="&gt;";break;case "<":c[a]="&lt;"}}function z(a){for(;;){++a;if(a>=u)return a;switch(d[a]){case "*":if("/"===d[a+1])return++a;break;case ">":case "<":b(a)}}}function k(a){var c;for(c=d[a];;){++a;if(a===u)return--a;switch(d[a]){case c:if("\\"!==d[a-1])return a;break;case ">":case "<":b(a)}}}function A(a){c[a]='<span class="operator">'+("<"===d[a]?"&lt;":">"===d[a]?"&gt;":d[a])+"</span>";return a}var c,d,u;return{init:function(a){d=
a.split("");u=d.length;c=d.slice();a:{var b;a=0;if(q&&(c[a]="*"===d[a]?' <span class="comment">*':'<span class="comment">'+d[a],"*"===d[0]&&"/"===d[1]?(q=!1,c[1]+="</span>",a=3):(a=z(a),a<u?(q=!1,c[a]+="</span>",++a):c[a-1]+="</span>"),a===u)){a=c.join("");break a}for(;a<u;a++)switch(d[a]){case "/":switch(d[a+1]){case "/":c[a]='<span class="comment">/';a=u-1;c[a]+="</span>";break;case "*":c[a]='<span class="comment">/';a=z(++a);a===u&&(q=!0,--a);c[a]+="</span>";break;default:if(b=0===a?"(":" "===
d[a-1]?d[a-2]:d[a-1],-1!==l.indexOf(b)){b=void 0;c[a]='<span class="regex">/';a=k(a);b=[];b:for(;;){if(3===b.length)break b;switch(d[a+1]){case "g":case "i":case "m":if(-1!==b.indexOf(d[a+1]))break b;b.push(d[a+1]);++a;break;default:break b}}c[a]+="</span>"}else a=A(a)}break;case "'":case '"':c[a]='<span class="string">'+d[a];a=k(a);c[a]+="</span>";break;case " ":c[a]='<span class="space"> ';b:for(;;){if(" "!==d[a+1])break b;++a}c[a]+="</span>";break;case "{":case "[":case "(":case ")":case "]":case "}":c[a]=
'<span class="bracket">'+d[a]+"</span>";break;case "*":case "%":case "+":case "-":case "<":case ">":case "&":case "^":case "|":case "=":case "!":case "~":case "?":a=A(a);break;case ",":c[a]='<span class="comma">,</span>';break;case ";":c[a]='<span class="semicolon">;</span>';break;case ":":c[a]='<span class="colon">:</span>';break;case ".":c[a]='<span class="period">.</span>';break;case "0":case "1":case "2":case "3":case "4":case "5":case "6":case "7":case "8":case "9":c[a]='<span class="number">'+
d[a];b:for(b=b=void 0,b=d[a]+d[a+1],b="0x"===b||"0X"===b?e:f;;){if(a===u-1||!b.test(d[a+1]))break b;++a}c[a]+="</span>";break;default:if(g.test(d[a])){b=void 0;b:{b=a;for(var x=void 0,x=[];;){x.push(d[b]);if(b===u-1||!m.test(d[b+1])){b={index:b,name:x.join("")};break b}++b}}switch(!0){case -1!==n.indexOf(b.name):c[a]="function"==b.name?"("===d[b.index+1]||" "===d[b.index+1]&&"("===d[b.index+2]?'<span class="reservedKeyword">'+d[a]:'<span class="definingKeyword">'+d[a]:'<span class="definingKeyword">'+
d[a];break;case -1!==t.indexOf(b.name):c[a]='<span class="reservedKeyword">'+d[a];break;case -1!==h.indexOf(b.name):c[a]='<span class="nativeKeyword">'+d[a];break;case -1!==p.indexOf(b.name):c[a]='<span class="valueKeyword">'+d[a];break;case -1!==r.indexOf(b.name):c[a]='<span class="clientKeyword">'+d[a];break;case -1!==v.indexOf(b.name):c[a]='<span class="jqueryKeyword">'+d[a];break;default:c[a]='<span class="identifier">'+d[a]}c[b.index]+="</span>";a=b.index}else c[a]='<span class="misc">'+d[a]+
"</span>"}a=c.join("")}return a}}}();return{init:function(e){e=String(e).replace(/\r\n?/g,"\n").replace(/\t/g," ").split("\n");var f,k,h;b=0;q=!1;h=e.length;for(f=0;f<e.length;f++){k=e[f];var c=void 0,d=void 0,g=void 0,a=void 0;k=k.split("");d=k.length;g=d-1;a={code:"",first:"",last:"",padding:0,empty:!1};c=0;a:for(;c<d;c++){if(" "===k[c])k[c]="";else{a.first=k[c];break a}c===g&&(a.empty=!0)}if(!a.empty)a:for(c=g;0<=c;c--)if(" "===k[c])k[c]="";else{a.last=k[c];break a}a.code=k.join("");k=a;if(!k.empty){c=
k;d=k.last;g=void 0;switch(k.first){case "}":case "]":case ")":--b}g=20*b;switch(d){case "{":case "[":case "(":case "?":++b}c.padding=g}k.empty||(k.code=w.init(k.code));e[f]='<li style="padding-left:'+k.padding+'px">'+k.code+"</li>"}return{result:e.join(""),lineCount:h}}}}()})(questions);}());
