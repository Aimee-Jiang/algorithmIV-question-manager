/* Algorithm IV (v1.0.1) (learn@algorithmiv.com)
 * Section: User Data, App Initialization, & Web Worker
 * Author: Adam Smith (adamsmith@youlum.com)
 * Copyright (c) 2015 Adam A Smith (github.com/imaginate)
 * The MIT License (algorithmiv.com/docs/license) */

/**
 * ------------------------------------------------------------------
 * Algorithm IV User Data (v1.0.1)
 * ------------------------------------------------------------------
 * manages a list of practice questions and detailed solutions
    for learning computer science focused algorithms and data
    structures, improving programming skillsets, and preparing
    for technical interviews
 * settings: configuration, categories, sources, and questions
 * directions:
   - see algorithmiv.com/docs/start
 */
(function() {
  "use strict";

  /**
   * -----------------------------------------------
   * Public Variable (configuration)
   * -----------------------------------------------
   * an object containing the configuration settings
      for this module
   * details:
     - see algorithmiv.com/docs/configuration
   */
  var configuration = {
    searchSettings: {
         stage: true,
        source: true,
      category: true,
        subCat: true
    },
    searchDefaults: {
         view: 'one',
        order: 'asc',
        stage: 'all',
       source: 'all',
      mainCat: 'all',
       subCat: 'all',
      startID: 6
    },
    questionFormat: {
            id: true,
      complete: true,
        source: true,
      category: true,
         links: true,
        output: true
    },
        id: true,
    worker: false
  };

  /**
   * -----------------------------------------------
   * Public Variable (sources)
   * -----------------------------------------------
   * an object containing all of the problem sources
   * details:
     - see algorithmiv.com/docs/sources
   */
  var sources = {
    'am': 'Amazon',
    'bl': 'Bloomberg',
    'fb': 'Facebook',
    'go': 'Google'
  };

  /**
   * -----------------------------------------------
   * Public Variable (categories)
   * -----------------------------------------------
   * an object containing each main and sub question
     category
   * details:
     - see algorithmiv.com/docs/categories
   */
  var categories = {
    main: {
      'array' : 'Arrays',
      'graph' : 'Graphs',
      'hash'  : 'Hashes',
      'list'  : 'Linked Lists',
      'search': 'Searching Algorithms',
      'sort'  : 'Sorting Algorithms',
      'tree'  : 'Trees'
    },
    sub: {
      'graph': {
        'adjList': 'Adjacency Lists',
        'adjMtrx': 'Adjacency Matrices',
        'arb'    : 'Arborescences',
        'digraph': 'Directed Graphs',
        'incList': 'Incidence Lists',
        'incMtrx': 'Incidence Matrices',
        'ungraph': 'Undirected Graphs'
      },
      'hash': {
        'dblHash': 'Double Hashing',
        'fnv'    : 'FNV Hash Algorithms',
        'hTable' : 'Hash Tables'
      },
      'list': {
        'sList': 'Singly-Linked Lists',
        'dList': 'Doubly-Linked Lists'
      },
      'search': {
        'back'   : 'Backtracking',
        'binSrch': 'Binary Search',
        'bfs'    : 'Breadth First Search',
        'brute'  : 'Brute Force Search',
        'dfs'    : 'Depth First Search',
        'dynam'  : 'Dynamic Programming'
      },
      'sort': {
        'bucket': 'Bucket Sort',
        'heapS' : 'Heapsort',
        'insert': 'Insertion Sort',
        'intro' : 'Introsort',
        'merge' : 'Mergesort',
        'quick' : 'Quicksort',
        'radix' : 'Radix Sort',
        'select': 'Select Sort',
        'smooth': 'Smoothsort'
      },
      'tree': {
        'binHeap': 'Binary Heaps',
        'binTree': 'Binary Trees',
        'bst'    : 'Binary Search Trees',
        'bnmHeap': 'Binomial Heaps',
        'fibHeap': 'Fibonacci Heaps',
        'red'    : 'Red-Black Trees',
        'splay'  : 'Splay Trees',
        'trie'   : 'Tries'
      }
    }
  };

  /**
   * ---------------------------------------------
   * Public Variable (questions)
   * ---------------------------------------------
   * an array of objects containing each question,
      its details, and your solution for it
   * details:
     - see algorithmiv.com/docs/questions
   */
  var questions = [
    {
      // Question: 1
      complete: true,
        source: 'fb',
       mainCat: [ 'search', 'tree', 'array' ],
        subCat: [ 'bfs', 'binTree' ],
         links: [
           {
             name: 'Further Discussion',
             href: 'http://www.careercup.com/question?id=4505011482525696'
           }
         ],
       problem: 'Write a function that prints the rows of a binary tree, terminating each row with a carriage return.',
      solution: function() {
        /*
         ** Solution:
         *  - Step 1: A binary tree is created. An array of
         *    nodes storing their value and a reference to
         *    their children is used to implement the tree.
         *  - Step 2: A Breadth First Search algorithm is used
         *    to traverse the tree and add the nodes in order
         *    by row to the result.
         *
         ** Need to Know Terms:
         *  - Algorithms:
         *    -- Breadth First Search (BFS): http://en.wikipedia.org/wiki/Breadth-first_search
         *  - Data Structures:
         *    -- Binary Tree: http://en.wikipedia.org/wiki/Binary_tree
         *    -- Arrays: http://en.wikipedia.org/wiki/Array_data_structure
         */

        // The binary tree
        // The node rows to be printed
        var tree, result;

        // Set variables
        tree = [];
        result = '';

        // Creates the binary tree
        function createTree() {
          // Node index
          // Edge index
          var n, e;

          // Add empty nodes to tree
          for (n=0; n<15; n++) {
              tree.push({ val: n, edges: [] });
          }

          // Set edge index
          e = 1;
          // Add edges to tree
          for (n=0; n<7; n++) {
            tree[n].edges.push(tree[e],tree[e+1]);
            e += 2;
          }
        }

        // Saves a string of the binary tree's nodes
        //   in order with a line break for each row
        function printNodes() {
          // The list of current nodes to be searched
          // The current node being searched
          // The max nodes possible in the current row
          // The count of nodes in the current row
          // The count of the node's edges
          // The edges index
          var list, node, rowMax, rowCount, edges, e;

          // Set list to array with tree root
          list = [ tree[0] ];
          // Set max of first row
          rowMax = 1;
          // Set current row count
          rowCount = 0;

          // Loop through nodes
          while (list.length > 0) {

            // Set node and remove first item
            node = list.shift();
            // Increase the count by one
            ++rowCount;
            // Set result
            result += node.val + ( (rowMax === rowCount) ? '<br />' : ',' );

            // If (row finished)
            // Then {double max and reset count}
            if (rowMax === rowCount) {
              rowMax = rowMax * 2;
              rowCount = 0;
            }

            // Save node's edge count
            edges = node.edges.length;
            // Add node's edges to list
            for (e=0; e<edges; e++) {
              list.push(node.edges[e]);
            }
          }
        }
        
        // Create tree and print nodes
        createTree();
        printNodes();
        return result;
      }
    },
    {
      // Question: 2
      complete: true,
        source: 'am',
       mainCat: [ 'search', 'graph', 'array' ],
        subCat: [ 'back', 'dynam', 'dfs', 'digraph', 'incList' ],
         links: [
           {
             name: 'Further Discussion',
             href: 'http://www.careercup.com/question?id=6031402409656320'
           }
         ],
       problem: 'Imagine a large city like Los Angeles. Suppose someone shows up at location A, then N minutes later at location B. Design a function that approximates the probability they passed a Starbucks.',
      solution: function() {
        /*
         ** Solution:
         *  - Step 1: A time weighted digraph of locations
         *    and a boolean value for whether a Starbucks is
         *    passed for each edge is created. An array of
         *    vertex nodes (storing its value and a reference
         *    to each of its edges) and edge nodes (storing
         *    its weight, Starbuck's value, and a reference
         *    to each of its connecting nodes) is used to
         *    implement the digraph.
         *  - Step 2: A recursive dynamic backtracking DFS
         *    algorithm is applied to traverse the digraph
         *    and find all of the paths possible to the
         *    destination within the provided maximum time
         *    frame and whether a Starbucks was passed on
         *    each path.
         *  - Step 3: The probability of passing a Starbucks
         *    is calculated.
         *
         ** Need to Know Terms:
         *  - Algorithms:
         *    -- Backtracking: http://en.wikipedia.org/wiki/Backtracking
         *    -- Dynamic Programming: http://en.wikipedia.org/wiki/Dynamic_programming
         *    -- Depth First Search (DFS): http://en.wikipedia.org/wiki/Depth-first_search
         *  - Data Structures:
         *    -- Directed Graph (Digraph): http://en.wikipedia.org/wiki/Directed_graph
         *    -- Weighted Graph: http://en.wikipedia.org/wiki/Glossary_of_graph_theory#Weighted_graphs_and_networks
         *    -- Incidence List: http://www.algorithmist.com/index.php/Graph_data_structures#Incidence_List
         *    -- Arrays: http://en.wikipedia.org/wiki/Array_data_structure
         */

        // The time weighted digraph
        // The starting vertex (starting location)
        // The final vertex (final destination)
        // The maximum weight of a path (minutes of time)
        // The final paths
        // The probability of passing a Starbucks
        // The visually prepared final results
        var graph, start, end, max, paths, prob, results;

        // Set variables
        graph = {
          vertices: [],
          edges: []
        };
        start =  0;
        end   =  9;
        max   = 50;
        paths = {
          list: [],
          starbucks: 0
        };
        prob  = 0;
        results = {
          count: {
            all: '',
            starbucks: ''
          },
          prob: '',
          paths: {
            all: '',
            starbucks: ''
          }
        };

        // Creates the weighted digraph
        function createGraph() {
          // The vertex index
          // The edge index
          // The edge's parent vertex
          // The edge's child vertex
          // The edge's weight
          // The edge's Starbuck's value
          var v, e, pNode, child, weight, starbucks;
          // The parent index
          // The child index
          // A shortcut function to add edge
          //   pointers to vertices
          var p, c, addPointer;
          
          // Set shortcut function
          // param: The vertex's index
          // param: An array of the edge's indexes
          addPointer = function(vertex, edges) {
            // The number of edges
            // The loop index
            // The edge node
            var len, i, node;
            
            // Save edges count
            len = edges.length;
            // Add each edge
            for (i=0; i<len; i++) {
              node = graph.edges[ edges[i] ];
              graph.vertices[vertex].edges.push(node);
            }
          }

          // Add vertices to graph
          for (v=0; v<10; v++) {
            graph.vertices.push({ val: v, edges: [] });
          }

          // Add edges to graph
          for (e=0; e<16; e++) {

            // Set weight and starbucks
            weight = 5;
            starbucks = (e === 5) ? true : false;
            // Set parent and child
            switch (true) {
              case (e < 3):
                p = 0;
                c = (e === 0) ? 1 : ++c;
                pNode = graph.vertices[p];
                child = graph.vertices[c];
              break;
              case (e < 5):
                p = 1;
                c = e;
                pNode = graph.vertices[p];
                child = graph.vertices[c];
              break;
              case (e < 7):
                p = 2;
                c = e;
                pNode = graph.vertices[p];
                child = graph.vertices[c];
              break;
              case (e === 7):
                p = 3;
                c = 6;
                pNode = graph.vertices[p];
                child = graph.vertices[c];
              break;
              case (e === 8):
                p = 4;
                c = 6;
                pNode = graph.vertices[p];
                child = graph.vertices[c];
              break;
              case (e < 12):
                p = 5;
                c = ++c;
                pNode = graph.vertices[p];
                child = graph.vertices[c];
              break;
              case (e < 14):
                p = 6;
                c = (e === 12) ? 7 : 9;
                pNode = graph.vertices[p];
                child = graph.vertices[c];
              break;
              case (e === 14):
                p = 7;
                c = 8;
                pNode = graph.vertices[p];
                child = graph.vertices[c];
              break;
              case (e === 15):
                p = 8;
                c = 9;
                pNode = graph.vertices[p];
                child = graph.vertices[c];
              break;
            }
            // Add edge
            graph.edges.push({
              pNode: pNode,
              child : child,
              weight: weight,
              starbucks: starbucks
            });
          }

          // Add edge pointers to vertices
          addPointer(0, [ 0,1,2 ]);
          addPointer(1, [ 3,4 ]);
          addPointer(2, [ 5,6 ]);
          addPointer(3, [ 7 ]);
          addPointer(4, [ 8 ]);
          addPointer(5, [ 9,10,11 ]);
          addPointer(6, [ 12,13 ]);
          addPointer(7, [ 14 ]);
          addPointer(8, [ 15 ]);
        }

        // Finds all of the paths possible
        //   within the max time
        function findPaths() {
          // The path being currently reviewed
          // A function that is called recursively
          //   to find each path
          var path, buildPaths;

          // Set the recursive DFS
          // param: The current node
          // param: The current cumulative weight
          // param: Whether a starbucks currently exists
          buildPaths = function(node, weight, starbucks) {
            // The string for the current path
            // The count of the node's edges
            // The edges index
            // The current edge's node
            // The new total path weight
            // The new starbucks value
            var edges, e, edge, newWeight, newStarbucks;

            // If (weight is greater than max weight)
            // Then {end this path traversal}
            if (weight > max) {
              return;
            }

            // If (node is destination)
            // Then {add path to results and end traversal}
            if (node.val === end) {

              // Save string of path
              path.string = '[ ' +
                path.values.join(',') + ',' + end +
              ' ]';

              // Add path to final list of paths
              paths.list.push({
                val: path.string,
                starbucks: starbucks
              });
              // Adjust count of Starbucks paths
              paths.starbucks += (starbucks) ? 1 : 0;

              // End this path traversal
              return;
            }

            // Add node to current path
            path.nodes.push(node);
            path.values.push(node.val);

            // Save the node's count of edges
            edges = node.edges.length;
            // Traverse each path rooting with each edge
            for (e=0; e<edges; e++) {
              // Save reference of edge's object
              edge = node.edges[e];
              // Set new weight total
              newWeight = weight + edge.weight;
              // Set new value for starbucks
              newStarbucks = (starbucks || edge.starbucks);
              // Continue search
              buildPaths(edge.child, newWeight, newStarbucks);
            }

            // Remove current node from path
            path.nodes.pop();
            path.values.pop();
          }

          // Set path to empty
          path = {
            nodes : [],
            values: [],
            string: ''
          };
          // Find the paths
          buildPaths(graph.vertices[start], 0, false);
        }

        // Calculates the probability of passing a Starbucks
        function calcProbability() {
          // Divide the number of paths with starbucks
          //   by the number of all paths and round up
          //   to the nearest whole percent
          prob = (paths.starbucks / paths.list.length) * 100;
          prob = Math.ceil(prob);
        }

        // Prepares an output for visual appeal
        function prepareResults() {
          // The count of paths
          // The first Starbucks path flag
          // The loop index
          var len, flag, i;

          // Save count of paths
          len = paths.list.length;
          
          // Set count results
          results.count.all = 'Count of All Paths: ' + len + '<br />';
          results.count.starbucks  = 'Count of All Paths with Starbucks: ';
          results.count.starbucks += paths.starbucks + '<br />';

          // Set probability result
          results.prob = 'Probability of Passing Starbucks: ' + prob + '%<br />';

          // Set path result headers
          results.paths.all = 'List of All Paths:';
          results.paths.starbucks = 'List of All Paths with Starbucks:';
          // Set path result containers
          results.paths.all += '<span style="display:block;margin-left:30px">';
          results.paths.starbucks += '<span style="display:block;margin-left:30px">';
          // Set first Starbucks flag
          flag = true;
          // Set path results
          for (i=0; i<len; i++) {
            results.paths.all += (i > 0) ? '<br />' : '';
            results.paths.all += paths.list[i].val;
            if (paths.list[i].starbucks) {
              // If (first path with Starbucks)
              // Then {change flag}
              // Else {add line break}
              if (flag) {
                flag = false;
              }
              else {
                results.paths.starbucks += '<br />';
              }
              results.paths.starbucks += paths.list[i].val;
            }
          }
          // Close path result containers
          results.paths.all += '</span>';
          results.paths.starbucks += '</span>';
        }

        // Create digraph, find paths,
        //   calculate probability, and
        //   return the prepared results
        createGraph();
        findPaths();
        calcProbability();
        prepareResults();
        return results.count.all + results.count.starbucks +
        results.prob + results.paths.all + results.paths.starbucks;
      }
    },
    {
      // Question: 3
      complete: true,
        source: 'go',
       mainCat: [ 'hash', 'search' ],
        subCat: [ 'hTable', 'dblHash', 'fnv', 'brute' ],
         links: [
           {
             name: 'Further Discussion',
             href: 'http://www.careercup.com/question?id=5724911848914944'
           }
         ],
       problem: 'Given a table of [Url =&gt; Content] pairs produce a new table of [Url =&gt; Duplicate Urls] pairs.<br /><br />' +
                'Example Input:<br />' +
                'a.com =&gt; &lt;html&gt;alpha&lt;/html&gt;<br />' +
                'b.com =&gt; &lt;html&gt;beta&lt;/html&gt;<br />' +
                'c.com =&gt; &lt;html&gt;gamma&lt;/html&gt;<br />' +
                'd.com =&gt; &lt;html&gt;alpha&lt;/html&gt;<br />' +
                'e.com =&gt; &lt;html&gt;alpha&lt;/html&gt;<br /><br />' +
                'Example Output:<br />' +
                'a.com =&gt; [ d.com, e.com ]<br />' +
                'b.com =&gt; []<br />' +
                'c.com =&gt; []',
      solution: function() {
        /*
         ** Solution:
         *  - Step 1: A hash table using the original
         *    urls as the keys and their page's content
         *    as the values is created.
         *  - Step 2: A hash table using a 32 bit hash
         *    of the page's content for each key and the
         *    content itself as the value is created. A
         *    modified FNV-1a hash algorithm is used to
         *    hash the content. After each new hash
         *    creation the original hash table is
         *    modified (i.e. the content is replaced
         *    with its hash).
         *  - Step 3: An optimized brute force algorithm
         *    is applied to visit each url and identify
         *    any urls with the duplicate content until
         *    all urls have been marked as unique or
         *    duplicated.
         *
         ** Need to Know Terms:
         *  - Algorithms:
         *    -- FNV Hash Algorithm: http://www.isthe.com/chongo/tech/comp/fnv/
         *    -- Double Hashing: http://en.wikipedia.org/wiki/Double_hashing
         *    -- Brute Force Search: http://en.wikipedia.org/wiki/Brute-force_search
         *  - Data Structures:
         *    -- Hash Table: http://en.wikipedia.org/wiki/Hash_table
         */
        
        // The supplied urls and their page's content
        // The hash table of all page's content
        // The list of urls and their duplicated content
        // The visually prepared duplicate results
        var inputs, hashes, duplicates, results;

        // Set variables
        inputs = {};
        hashes = {};
        duplicates = {};
        results = [];

        // Adds the original list of urls
        function setupInputs() {
          // Add urls to inputs
          inputs['a.com'] = '<html>alpha</html>';
          inputs['b.com'] = '<html>beta</html>';
          inputs['c.com'] = '<html>gamma</html>';
          inputs['d.com'] = '<html>alpha</html>';
          inputs['e.com'] = '<html>alpha</html>';
        }

        // Hashes a string with the FNV-1a hash algorithm
        // param: The string to be hashed
        // param: The hashed collision
        // param: The extra rotations to resolve a collision
        function createHash(string, hash, extras) {
          // The FNV offset basis for the hash
          // The FNV prime number to use for multiplication
          // The string length
          // The loop index
          var offset, prime, len, i;

          // Set offset and prime to the 32 bit FNV values
          offset = 2166136261;
          prime  = 16777619;

          // If (no hash supplied)
          // Then {create new hash}
          // Else {resolve collision}
          if (typeof hash === 'undefined') {

            // Offset the hash
            hash = offset;

            // Save string length
            len = string.length;
            // Loop through each string character
            for (i=0; i<len; i++) {
              // XOR and multiply by prime
              hash = hash ^ string.charAt(i);
              hash = hash * prime;
            }
          }
          else {

            // Loop through each extra time
            for (i=0; i<extras; i++) {
              // XOR and multiply by prime
              hash = hash ^ string.charAt(i);
              hash = hash * prime;
            }
          }

          return hash;
        }

        // Creates a hash table for the url page's content
        function createHashTable() {
          // Function that adds hash to table
          // The current url
          // The current url's content
          // The current content's hash
          // Indicator to check if collision has occurred
          var addHash, url, content, hash, flag;

          // Set addHash function
          addHash = function(theUrl, theContent, theHash) {

            // If (hash does not exist in table)
            if (typeof hashes[theHash] === 'undefined') {
              // Add hash key to table
              hashes[theHash] = {
                collisions: 0,
                content: theContent
              };
              // Replace inputs content with hash
              inputs[theUrl] = theHash;
            }
            else {
              // If (no collision)
              // Then {replace inputs content with hash}
              // Else {add collision, create new hash, and repeat process}
              if (theContent === hashes[theHash].content) {
                inputs[theUrl] = theHash;
              }
              else {
                ++hashes[theHash].collisions;
                theHash = createHash(theContent, theHash, hashes[theHash].collisions);
                addHash(theUrl, theContent, theHash);
              }
            }
          }

          // Loop through supplied inputs
          for (url in inputs) {
            // Filter out default javascript properties
            if ( inputs.hasOwnProperty(url) ) {

              // Save, hash, and add the content and 
              //   hash to the hash table
              content = inputs[url];
              hash = createHash(content);
              addHash(url, content, hash);
            }
          }
        }

        // Finds the duplicated url page's content
        function findDuplicates() {
          // The list of the urls to check
          // The current url
          // The current length of the url list
          // The loop index
          // The next url
          // The loop count
          var urls, url, len, i, next, l;

          // Set the url list to empty then
          //   add all the urls to it
          urls = [];
          for (url in inputs) {
            if ( inputs.hasOwnProperty(url) ) {
              urls.push(url);
            }
          }

          // Loop through url list
          while (urls.length > 0) {

            // Save and remove first url on list
            url = urls.shift();
            // Add a property to the duplicates
            //   object with the url as the key
            duplicates[url] = [];

            // Save the current url list length
            len = urls.length;
            // Set index and loop count to 0
            i = l = 0;
            // Loop through url list
            for (; l<len; l++) {

              // Save the next url
              next = urls[i];

              // If (urls content matches)
              // Then {save to duplicates and remove from url list}
              // Else {increase index}
              if (inputs[url] === inputs[next]) {
                duplicates[url].push(next);
                urls.splice(i, 1);
              }
              else {
                ++i;
              }
            }
          }
        }

        // Prepares the results to be returned
        function prepareResults() {
          // The current url
          var url;

          // Add each url to the results array
          for (url in duplicates) {
            if ( duplicates.hasOwnProperty(url) ) {
              results.push(url + ' => [ ' + duplicates[url].join(',') + ' ]');
            }
          }
        }

        // Setup data structures, find duplicated
        //   content, and return visually
        //   prepared results
        setupInputs();
        createHashTable();
        findDuplicates();
        prepareResults();
        return results.join('<br />');
      }
    },
    {
      // Question: 4
      complete: true,
        source: 'go',
       mainCat: [ 'search', 'tree', 'graph', 'hash', 'array' ],
        subCat: [ 'brute', 'back', 'dfs', 'trie', 'arb', 'digraph', 'adjList', 'hTable' ],
         links: [
           {
             name: 'Further Discussion',
             href: 'http://www.careercup.com/question?id=6270813198090240'
           }
         ],
       problem: 'You are given a string of four lower case characters and a dictionary of english words. Choose a data structure to represent the dictionary and write an algorithm that returns all the words from the dictionary that can be formed by the characters of the string.<br />' +
                'Example:<br />' +
                'string = \'ogeg\'<br />' +
                'words = [ \'egg\',\'ego\', ... ]',
      solution: function() {
        /*
         ** Solution:
         *  - Step 1: A json dictionary of English words is
         *    downloaded for use via ajax.
         *  - Step 2: A brute force search algorithm is used
         *    to create a trie of only the words from the
         *    dictionary that have a max of 4 characters
         *    and begin with a letter from the given string.
         *    A hash table with the key set to the current
         *    substring and the value set to a node
         *    containing a boolean value for whether the
         *    substring is a word, the string value of the
         *    substring, and an array of references to its
         *    child nodes is used to represent the trie.
         *  - Step 3: An arborescence is constructed for all
         *    of the characters in the supplied string.
         *  - Step 4: A backtracking algorithm is used to
         *    find all of the possible words resulting from
         *    the arborescence of the supplied string.
         *
         ** Need to Know Terms:
         *  - Algorithms:
         *    -- Brute Force Search: http://en.wikipedia.org/wiki/Brute-force_search
         *    -- Backtracking: http://en.wikipedia.org/wiki/Backtracking
         *    -- Depth First Search (DFS): http://en.wikipedia.org/wiki/Depth-first_search
         *  - Data Structures:
         *    -- Trie: http://www.geeksforgeeks.org/trie-insert-and-search/
         *    -- Arborescence: http://en.wikipedia.org/wiki/Arborescence_(graph_theory)
         *    -- Directed Graph (Digraph): http://en.wikipedia.org/wiki/Directed_graph
         *    -- Adjacency List: http://en.wikipedia.org/wiki/Adjacency_list
         *    -- Hash Table: http://en.wikipedia.org/wiki/Hash_table
         *    -- Arrays: http://en.wikipedia.org/wiki/Array_data_structure
         *
         ** Copyright Notice:
         *  - The list of English words used to create the test data
         *    for this question was derived from the EOWL and UKACD.
         *  - See github.com/imaginate/algorithmIV/blob/master/example/resources/words.json
         *  - See http://dreamsteep.com/projects/the-english-open-word-list.html
         *  - Copyright (c) J Ross Beresford 1993-1999. All Rights Reserved.
         *  - Copyright Details: http://cfajohnson.com/wordfinder/UKACD17.shtml 
         */

        // A list of English words for this test
        // An array of all the string's letters and an
        //   indicator of how many duplicates exist
        // A trie of words with a max length of 4
        //   characters and starting with each of
        //   the string's characters
        // The input string
        // The arborescence of the string's characters
        // The resulting possible words from the string
        var words, letters, wordTrie, string, graph, results;

        // Setup variables
        words    = {};
        letters  = {
          list: [],
          dupl: 0
        }
        wordTrie = {};
        string   = 'ogeg';
        graph    = {};
        results  = [];

        // Download the json dictionary
        function makeAjaxCall() {
          // Contains the ajax call
          var http;

          http = new XMLHttpRequest();
          http.onreadystatechange = function() {
            // If (ajax finished)
            if (http.readyState === 4 && http.status === 200) {
              // Sanitize and set the words list
              words = JSON.parse(http.responseText);
            }
          };
          http.open('GET', 'resources/words.json', false);
          http.send();
        }

        // Removes string's duplicate letters
        function setLetters() {
          // The loop index
          // The list of letter duplicates
          // The current letter
          var i, duplList, letter;

          // Set duplicate list
          duplList = [];

          // Save letters and duplicates
          for (i=0; i<4; i++) {

            // Save letter
            letter = string.charAt(i);
            // If (no duplicates exist)
            // Then {add letter to list}
            // Else {add letter to duplicates and trigger flag}
            if (letters.list.indexOf(letter) === -1) {
              letters.list.push(letter);
            }
            else {
              duplList.push(letter);
              ++letters.dupl;
            }
          }

          // Sort lists
          letters.list.sort();
          duplList.sort();
          // Append duplicates to main list
          letters.list = letters.list.concat(duplList);
        }

        // Create the trie of words
        function createWordTrie() {
          // The count of unique letters
          // The letter index
          var len, i;

          // Save the letters count
          len = letters.list.length - letters.dupl;
          // Add a branch to the trie for each letter
          for (i=0; i<len; i++) {
            addTrieBranch(letters.list[i]);
          }
        }

        // Adds a branch to the root of trie
        // param: the starting value of the branch
        function addTrieBranch(letter) {
          // The word loop index
          // The count of words
          // The current word
          // The current word length
          // The substring loop index
          // The last character index
          var i, wordsLen, word, wordLen, c, last;
          // The previous word substring
          // The new word substring
          var pNode, child;
          
          // Add branch to trie
          wordTrie[letter] = {
            isWord: false,
             value: letter,
              kids: []
          };
          // Save words length
          wordsLen = words[letter].length;

          // Loop through words
          for (i=0; i<wordsLen; i++) {
            
            // Save word and word length
            word = words[letter][i];
            wordLen = word.length;

            // If (word has less than 5 characters)
            // Then {add word to trie}
            if (wordLen < 5) {

              // If (word is one character)
              // Then {set root end prop to true}
              // Else {add word to trie}
              if (wordLen === 1) {
                wordTrie[letter].isWord = true;
              }
              else {

                // Save last index
                last = wordLen - 1;
                // Save child start
                child = letter;
                // Loop through the word's characters
                for (c=1; c<=last; c++) {

                  // Save current string
                  pNode = child;
                  child += word.charAt(c);

                  // If (child does not exist)
                  // Then {add to trie}
                  // Else {update isWord}
                  if (typeof wordTrie[child] === 'undefined') {
                    wordTrie[child] = {
                      isWord: (c === last),
                       value: child,
                        kids: []
                    };
                    wordTrie[pNode].kids.push(wordTrie[child]);
                  }
                  else {
                    wordTrie[child].isWord = wordTrie[child].isWord || (c === last);
                  }
                }
              }
            }
          }
        }

        // Create arborescence for the supplied string
        function createGraph() {
          // A function to add the letter nodes
          var addKids;

          // Adds each letter's child nodes recursively
          // param: The parent node
          // param: The remaining list
          // param: Indicates whether this is the first pass
          //   and whether list duplicates exist (optional)
          addKids = function(node, list, unique) {
            // The count of the remaining letters
            // The loop index
            // The new substring
            // The child node
            // The newList copy
            var len, i, word, child, copy;

            // Set unique
            unique = unique || false;
            // Set count
            len = list.length - ( (unique) ?
              letters.dupl : 0
            );
            // For each remaining letter
            for (i=0; i<len; i++) {

              // Save new value and child
              word  = node.val + list[i];
              child = { val: word, kids: [] };
              // Add child to parent
              node.kids.push(child);
              // If (remaining letters)
              if (len > 1) {

                // Save modified list
                copy = list.slice(0);
                copy.splice(i, 1);
                // Call recursive function
                addKids(child, copy);
              }
            }
          }

          // Setup graph base
          graph = { val: '', kids: [] };
          // Add branches
          addKids(graph, letters.list, !letters.dupl);
        }

        // Finds all of the possible words resulting from the string
        function findWords() {
          // A function to recursively handle the DFS
          var backtrack;

          // Recursively backtrack to find words
          // param: The current node
          backtrack = function(node) {
            // The count of children
            // The loop index
            // The current child
            var len, i, child;

            // Set count
            len = node.kids.length;
            // Loop through children
            for (i=0; i<len; i++) {

              // Set child node
              child = node.kids[i];

              // If (partial word exists)
              // Then {continue search}
              if (!!wordTrie[child.val]) {

                // If (partial word is complete)
                // Then {add word to results}
                if (wordTrie[child.val].isWord &&
                    results.indexOf(child.val) === -1) {
                    results.push(child.val);
                }

                // Continue DFS
                backtrack(child);
              }
            }
          }

          // Start recursive search
          backtrack(graph);
        }

        // Download dictionary, create trie of words,
        //   create arborescence of input string
        //   characters, find the possible words, and
        //   return the results
        makeAjaxCall();
        setLetters();
        createWordTrie();
        createGraph();
        findWords();
        return '[ ' + results.sort().join(',') + ' ]';
      }
    },
    {
      // Question: 5
      complete: true,
        source: 'bl',
       mainCat: [ 'search', 'graph', 'hash', 'array' ],
        subCat: [ 'dfs', 'brute', 'digraph', 'adjList', 'hTable' ],
         links: [
           {
             name: 'Further Discussion',
             href: 'http://www.careercup.com/question?id=5768610725232640'
           }
         ],
       problem: 'Using the below node list find the path that uses all the nodes without duplicating one.<br />' +
                '[ JFK,LXA,SNA,RKJ,LXA,SNA ]<br />' +
                'Note: Each pair of nodes define a directed edge like so:<br />' +
                '[ (JFK -&gt; LXA),(SNA -&gt; RKJ),(LXA -&gt; SNA) ]<br />',
      solution: function() {
        /*
         ** Solution:
         *  - Step 1: A brute force search algorithm is
         *    used to create an arborescence of the nodes
         *    in a vector while simultaneously building
         *    an array containing the two node values
         *    that are not duplicated (i.e. the
         *    possible arborescence roots). A hash
         *    table with a key set to the location
         *    string and a value set to a node
         *    containing the location string and edge
         *    references is used to represent the
         *    arborescence.
         *  - Step 2: The two possible root node
         *    values are checked, and the node value
         *    that is not the root is removed from the
         *    array.
         *  - Step 3: One pass of a DFS algorithm is
         *    used to print the path of the nodes.
         *
         ** Need to Know Terms:
         *  - Algorithms:
         *    -- Brute Force Search: http://en.wikipedia.org/wiki/Brute-force_search
         *    -- Depth First Search (DFS): http://en.wikipedia.org/wiki/Depth-first_search
         *  - Data Structures:
         *    -- Arborescence: http://en.wikipedia.org/wiki/Arborescence_(graph_theory)
         *    -- Directed Graph (Digraph): http://en.wikipedia.org/wiki/Directed_graph
         *    -- Adjacency List: http://en.wikipedia.org/wiki/Adjacency_list
         *    -- Hash Table: http://en.wikipedia.org/wiki/Hash_table
         *    -- Arrays: http://en.wikipedia.org/wiki/Array_data_structure
         */

        // Original node list
        // Arborescence of nodes
        // Possible root nodes
        // Final node path
        var vector, graph, roots, result;

        // Set variables
        vector = [ 'JFK','LXA','SNA','RKJ','LXA','SNA' ];
        graph  = {};
        roots  = [];
        result = [];

        // Adds unique node keys to the roots list
        //   and removes duplicates
        // param: node value to check
        function addRoot(nodeVal) {
          // Index of node in roots array
          var i;

          // Save node index
          i = roots.indexOf(nodeVal);

          // If (node value is not in roots)
          // Then {add to roots}
          // Else {remove from roots}
          if (i === -1) {
            roots.push(nodeVal);
          }
          else {
            roots.splice(i, 1);
          }

          return (i === -1);
        }

        // Creates an arborescence of the nodes
        function createGraph() {
          // The vector length
          // The loop index
          // The current node value
          // Indicates whether to add new node
          // The vertex node
          // The edge node
          var len, i, nodeVal, check, vertex, edge;

          // Save vector length
          len = vector.length;

          // Add nodes
          for (i=0; i<len; i++) {

            // Set and check node value
            nodeVal = vector[i];
            check   = addRoot(nodeVal);
            // If (node value does not exist)
            // Then {add node}
            if (check) {
              graph[nodeVal] = {
                value: nodeVal,
                edges: []
              }
            }
          }

          // Add edges
          for (i=0; i<len; i++) {

            // Set vertex and edge
            vertex = graph[ vector[i] ];
            edge   = graph[ vector[++i] ];
            // Add edge to vertex
            vertex.edges.push(edge);
          }
        }

        // Finds the root node
        function findRoot() {
          // The loop index
          // The current node
          var i, node;

          // Loop through roots
          for (i=0; i<2; i++) {

            // Save node reference
            node = graph[ roots[i] ];
            // If (node does not have an edge)
            // Then {remove it from roots}
            if (node.edges.length === 0) {
              roots.splice(i, 1);
            }
          }
        }

        // Finds the resulting path
        function findPath() {
          // The current node
          // The count of edges
          var node, edges;

          // Set node to root node
          node = graph[ roots[0] ];

          // Run DFS
          while (!!node) {

            // Add current node value to results
            result.push(node.value);
            // Save count of edges
            edges = node.edges.length;
            // If (node has edge)
            // Then {set next node to edge}
            // Else {end loop}
            node = ( (edges > 0) ?
              node.edges[0] : !node
            );
          }
        }

        // Create arborescence, find root
        //   node, find final path, and
        //   return the result
        createGraph();
        findRoot();
        findPath();
        return result.join(' -&gt; ');
      }
    },
    {
      // Question: 6
      complete: false,
        source: 'go',
       mainCat: [ 'sort', 'tree', 'list', 'array' ],
        subCat: [ 'heapS', 'brute', 'binHeap', 'bst', 'dList' ],
         links: [
           {
             name: 'Further Discussion on BST to Linked List',
             href: 'http://www.careercup.com/question?id=4863668900593664'
           }
         ],
       problem: 'Given an array of random numbers, create a binary search tree with the median as the root. Then convert the binary search tree into a doubly-linked list that is sorted in ascending or descending order and return the first node in the list. Do the sort and conversion in place<span style="margin:0 12px">&ndash;</span>i.e. the memory complexity of your algorithms should be <em style="margin:0 2px">&Omicron;</em>(1).' +
                '<span style="display:block;margin:15px 0 10px">Example diagram of conversion:</span>'  +
                '<style>' +
                  '.aIV-exQ3-table {padding:0;margin:0;text-align:center;border:0}' +
                  '.aIV-exQ3-table td {padding:0;margin:0;text-align:center}'       +
                '</style>' +
                '<table class="aIV-exQ3-table">' +
                  '<tr>' +
                    '<td><u>Unsorted Array</u></td>' +
                    '<td></td>' +
                    '<td><u>Binary Search Tree</u></td>' +
                    '<td></td>' +
                    '<td><u>Doubly-Linked List</u></td>' +
                  '</tr>' +
                  '<tr>'  +
                    '<td></td>'  +
                    '<td></td>'  +
                    '<td>7</td>' +
                    '<td></td>'  +
                    '<td></td>'  +
                  '</tr>' +
                  '<tr>'  +
                    '<td>[&nbsp;&nbsp;7,3,9&nbsp;&nbsp;]</td>' +
                    '<td style="padding:0 20px">to</td>'     +
                    '<td>&sol;&nbsp;&nbsp;&nbsp;&bsol;</td>' +
                    '<td style="padding:0 20px">to</td>'     +
                    '<td>3&nbsp;&nbsp;&lrarr;&nbsp;&nbsp;7&nbsp;&nbsp;&lrarr;&nbsp;&nbsp;9</td>' +
                  '</tr>' +
                  '<tr>'  +
                    '<td></td>' +
                    '<td></td>' +
                    '<td>3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9</td>' +
                    '<td></td>' +
                    '<td></td>' +
                  '</tr>' +
                '</table>',
      solution: function() {
        /*
         ** Solution:
         *  - [explanation]
         *
         ** Need to Know Terms:
         *  - Algorithms:
         *    -- Heapsort: http://en.wikipedia.org/wiki/Heapsort
         *    -- Brute Force Search: http://en.wikipedia.org/wiki/Brute-force_search
         *  - Data Structures:
         *    -- Binary Heap: http://en.wikipedia.org/wiki/Binary_heap
         *    -- Binary Search Tree: http://en.wikipedia.org/wiki/Binary_search_tree
         *    -- Doubly-Linked List: http://en.wikipedia.org/wiki/Doubly_linked_list
         *    -- Arrays: http://en.wikipedia.org/wiki/Array_data_structure
         */

        // The provided array of random numbers
        // The binary search tree
        // The starting node for the doubly-linked list
        // The final results
        var vals, tree, list, results;

        // Set variables
        vals = [ 88,97,56,41,27,16,95,54,28 ];
        tree = {
          val  : null,
          left : null,
          right: null
        };
        list = {
          val  : null,
          left : null,
          right: null
        };
        results = {
          bst  : [],
          list : [],
          first: ''
        };

        // Sorts the array of random numbers
        function sortValues() {
          // A function to convert the unsorted
          //   array into a heap
          // A function to construct the heap
          // A function to sort the heap
          var createHeap, heapify, sortHeap;

          // Creates a binary heap of the values
          createHeap = function() {
            // The number of provided values
            // The last value's index
            // The current value
            var len, last, val;

            // Save count of values
            len = vals.length;
            // Save last index
            last = len - 1;
            // Save first parent index
            val = (len - 2) / 2;
            val = Math.floor(val);

            // Build heap
            for (; val>=0; val--) {
              heapify(val, last);
            }
          }

          // Ensures the nodes are in heap order
          // param: The index of the starting node
          // param: The index of the ending node
          heapify = function(start, end) {
            // The parent index
            // The left child index
            // The right child index
            // The index of the biggest value
            var prt, left, right, max;

            // Set the first parent and child
            prt  = start;
            left = (prt * 2) + 1;

            // Check each parent node
            while (left <= end) {

              // Set max
              max = (vals[left] > vals[prt]) ? left : prt;

              // Set right child
              right = left + 1;
              // If (right child exists)
              // Then {check max value}
              if (right <= end) {
                max = (vals[right] > vals[max]) ? right : max;
              }

              // If (parent is max)
              // Then {end heapify}
              if (prt === max) {
                return;
              }

              // Swap parent and child values
              vals[max] = ( vals[prt] + (vals[prt] = vals[max]) ) - vals[max];

              // Set new parent and child indexes
              prt  = max;
              left = (prt * 2) + 1;
            }
          }

          // Sorts the heap
          sortHeap = function() {
            // The last index of the heap size
            var i;

            // Set index to the heap's last
            i = vals.length - 1;
            // Sort heap
            while (i > 0) {
            
              // Move the max (root) value to the end of the heap
              vals[i] = ( vals[0] + (vals[0] = vals[i]) ) - vals[i];

              // Reduce the heap size by 1
              --i;

              // Repair the heap missing its root
              heapify(0, i);
            }
          }
          
          // Run heapsort on array of values
          createHeap();
          sortHeap();
        }

        // Creates the binary search tree
        function createTree() {
          // A recursive function to set left children
          // A recursive function to set right children
          // The median heap index
          // The last index of the heap
          var setLeft, setRight, median, last;

          // Sets the left children
          // param: the parent node
          // param: the parent index
          // param: the starting index
          setLeft = function(node, p, start) {
            
          };

          // Sets the right children
          // param: the parent node
          // param: the parent index
          // param: the ending index
          setRight = function(node, p, end) {
            
          };

          // Find and set root to median value
          median = vals.length / 2;
          median = Math.floor(median);
          tree.val = median;

          // Set root's left and right children
          setLeft(tree, median, 0);
          last = vals.length - 1;
          setRight(tree, median, last);
        }
        
        // Creates the doubly-linked list
        function createList() {
          // A function that moves the minimum
          //   BST value to the linked list
          // A function that moves the maximum
          //   BST value to the linked list
          var moveMin, moveMax;

          // Moves the min tree value to the list
          // param: the parent node
          // param: the last list node
          moveMin = function(pNode, lNode) {
            // The current node
            var node;

            //
          };
          
          // Moves the max tree value to the list
          // param: the parent node
          // param: the last list node
          moveMax = function(pNode, lNode) {
            // The current node
            var node;

            //
          };
        }
        
        // Sets the first node in the list
        function prepareResults() {
        }

        // Sort the values, create the BST,
        //   convert the BST to a list,
        //   and share the results
        sortValues();
        createTree();
        createList();
        prepareResults();
        return ;
      }
    },
    {
      // Question: 7
      complete: false,
        source: 'fb',
       mainCat: [],
        subCat: [],
         links: [
           {
             name: 'Further Discussion',
             href: 'http://www.careercup.com/question?id=5748231105413120'
           }
         ],
       problem: 'Given a Tree:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\<br />&nbsp;&nbsp;&nbsp;B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C<br />&nbsp;&nbsp;/ \\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/ \\<br />D&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;&nbsp;F&nbsp;&nbsp;&nbsp;G<br /><br />Write a function that prints:<br />A<br />BC<br />DEFG',
      solution: function() {
        /*
         ** Solution:
         *  - [explanation]
         *
         ** Need to Know Terms:
         *  - Algorithms:
         *    -- [term]: [link]
         *  - Data Structures:
         *    -- [term]: [link]
         */
      }
    },
    {
      // Question: 8
      complete: false,
        source: 'go',
       mainCat: [],
        subCat: [],
         links: [
           {
             name: 'Further Discussion',
             href: 'http://www.careercup.com/question?id=6295449935806464'
           }
         ],
       problem: 'Represent the following in a data structure:<br />&lt;html&gt;&lt;body&gt;&lt;div&gt;&lt;span&gt;TEXT1&lt;/span&gt;&lt;br/&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;<br /><br />Do I do the same using a stack or create a tree for the same?',
      solution: function() {
        /*
         ** Solution:
         *  - [explanation]
         *
         ** Need to Know Terms:
         *  - Algorithms:
         *    -- [term]: [link]
         *  - Data Structures:
         *    -- [term]: [link]
         */
      }
    },
    {
      // Question: 9
      complete: false,
        source: 'am',
       mainCat: [],
        subCat: [],
         links: [
           {
             name: 'Further Discussion',
             href: 'http://www.careercup.com/question?id=5082499984130048'
           }
         ],
       problem: 'Design a data structure that can do the following operations in O(1) time:<br />Insert, Delete, Search, Max (returns the maximum number)<br /><br />I know delete, search and insert can be done O(1) time in a hashmap with a proper hash function, but not sure Max is even possible in O(1) with the presence of delete operation?',
      solution: function() {
        /*
         ** Solution:
         *  - [explanation]
         *
         ** Need to Know Terms:
         *  - Algorithms:
         *    -- [term]: [link]
         *  - Data Structures:
         *    -- [term]: [link]
         */
      }
    },
    {
      // Question: 10
      complete: false,
        source: 'am',
       mainCat: [],
        subCat: [],
         links: [
           {
             name: 'Further Discussion',
             href: 'http://www.careercup.com/question?id=6260358392053760'
           }
         ],
       problem: 'You are given two integer arrays A and B.<br /><br />1&lt;=i&lt;=len(A) so i is iterator of array A<br />1&lt;=j&lt;=len(B) so j is iterator of array B<br /><br />Find all the pairs (i,j) such that : i &lt; j and A[i]&gt;B[j].',
      solution: function() { 
        /*
         ** Solution:
         *  - [explanation]
         *
         ** Need to Know Terms:
         *  - Algorithms:
         *    -- [term]: [link]
         *  - Data Structures:
         *    -- [term]: [link]
         */
      }
    }
  ];

/* ---------------------------- *
 * -- DO NOT EDIT BELOW HERE -- *
 * ---------------------------- */
(function(s,y,k,w){var r=s||{},u=y||{};k=k||{};w=w||[];r.searchSettings=s.searchSettings||{};r.searchDefaults=s.searchDefaults||{};r.questionFormat=s.questionFormat||{};r.prettyCode=s.prettyCode||{};u.main=y.main||{};u.sub=y.sub||{};"undefined"!==typeof window&&algorithmIV.init(r,u,k,w)})(configuration,categories,sources,questions);
(function(s){onmessage=function(b){b=b.data;y=b.qLen;k=b.configuration;w=b.sources;r=b.categories;u.init();self.postMessage(k.content)};var y,k={},w={},r={},u=function(){var b;return{init:function(){var v;for(v=0;v<y;v++){b={id:{flag:!1,content:""},source:{flag:!1,content:""},complete:{flag:!1,content:""},category:{flag:!1,main:{flag:!1,h3:"",p:""},sub:{flag:!1,h3:"",p:""}},solution:{error:!1,code:"",height:0},output:{flag:!1,content:""},links:{flag:!1,content:[]}};var f=void 0,c=void 0,f=k.questionFormat.id,
c="";f&&(c=v+1,c=10>c?"00"+c:100>c?"0"+c:""+c);b.id.flag=f;b.id.content=c;f=s[v].source;c=void 0;c=0<w.len&&k.questionFormat.source;b.source.flag=c;b.source.content=c?w.list[f]:"";f=s[v].complete;b.complete.flag=k.questionFormat.complete;b.complete.content=k.questionFormat.complete?f?"Yes":"No":"";var f=s[v].mainCat,c=s[v].subCat,l=void 0,u=void 0,z=void 0,t=l=void 0,g=void 0,p=l=void 0,t=void 0,l=r.len.main,t=f.length,g=c.length,l=0<l&&k.questionFormat.category,u=0<t,z=0<g;b.category.flag=l;b.category.main.flag=
u;b.category.sub.flag=z;if(l){if(u)for(b.category.main.h3="Main "+(1<t?"Categories:":"Category:"),l=0;l<t;l++)b.category.main.p+=0===l?"":", ",b.category.main.p+=r.main[f[l]];if(0<g)for(b.category.sub.h3="Sub "+(1<g?"Categories:":"Category:"),l=0;l<g;l++)a:for(p in b.category.sub.p+=0===l?"":", ",r.sub)if(r.sub.hasOwnProperty(p)&&(t=r.sub[p],"string"===typeof t[c[l]])){b.category.sub.p+=t[c[l]];break a}}f=s[v].solution;p=g=c=void 0;c="function"!==typeof f;c||(g=B.init(f),p=g.lineCount*k.prettyCode.liHeight,
p+=k.prettyCode.olHeight);b.solution.error=c;b.solution.code=c?"":g.result;b.solution.height=c?0:p;f=s[v].solution;g=c=void 0;g=(c="function"===typeof f&&k.questionFormat.output)?f():"";g="string"!==typeof g?String(g):g;b.output.flag=c;b.output.content=g;f=s[v].links;p=g=c=void 0;g=f.length;if(c=0<g&&k.questionFormat.links)for(p=0;p<g;p++)b.links.content.push({href:f[p].href,name:f[p].name});else b.links.content=[];b.links.flag=c;k.content.push(b)}}}}(),B=function(){var b,k="([{;*/%+-<>&^|=!".split(""),
f=/[0-9\.]/,c=/[a-f0-9x\.]/i,l=/[a-z_\$]/i,s=/[a-z0-9_\$]/i,r={def:"defKey",res:"resKey",nat:"natKey",val:"valKey",cli:"cliKey",jqu:"jquKey"},t={"-class":{cat:"def",props:null},"-const":{cat:"def",props:null},"-function":{cat:"def",props:null},"-var":{cat:"def",props:null},"-abstract":{cat:"res",props:null},"-arguments":{cat:"res",props:null},"-boolean":{cat:"res",props:null},"-break":{cat:"res",props:null},"-byte":{cat:"res",props:null},"-case":{cat:"res",props:null},"-catch":{cat:"res",props:null},
"-char":{cat:"res",props:null},"-continue":{cat:"res",props:null},"-debugger":{cat:"res",props:null},"-default":{cat:"res",props:null},"-delete":{cat:"res",props:null},"-do":{cat:"res",props:null},"-double":{cat:"res",props:null},"-else":{cat:"res",props:null},"-enum":{cat:"res",props:null},"-export":{cat:"res",props:null},"-extends":{cat:"res",props:null},"-final":{cat:"res",props:null},"-finally":{cat:"res",props:null},"-float":{cat:"res",props:null},"-for":{cat:"res",props:null},"-goto":{cat:"res",
props:null},"-if":{cat:"res",props:null},"-implements":{cat:"res",props:null},"-import":{cat:"res",props:null},"-in":{cat:"res",props:null},"-instanceof":{cat:"res",props:null},"-int":{cat:"res",props:null},"-interface":{cat:"res",props:null},"-item":{cat:"res",props:null},"-let":{cat:"res",props:null},"-long":{cat:"res",props:null},"-native":{cat:"res",props:null},"-new":{cat:"res",props:null},"-package":{cat:"res",props:null},"-private":{cat:"res",props:null},"-protected":{cat:"res",props:null},
"-public":{cat:"res",props:null},"-return":{cat:"res",props:null},"-short":{cat:"res",props:null},"-static":{cat:"res",props:null},"-super":{cat:"res",props:null},"-switch":{cat:"res",props:null},"-synchronized":{cat:"res",props:null},"-this":{cat:"res",props:null},"-throw":{cat:"res",props:null},"-throws":{cat:"res",props:null},"-transient":{cat:"res",props:null},"-try":{cat:"res",props:null},"-typeof":{cat:"res",props:null},"-void":{cat:"res",props:null},"-volatile":{cat:"res",props:null},"-while":{cat:"res",
props:null},"-with":{cat:"res",props:null},"-yield":{cat:"res",props:null},"-apply":{cat:"nat",props:null},"-Array":{cat:"nat",props:{"-from":1,"-isArray":1,"-observe":1,"-of":1}},"-ArrayBuffer":{cat:"nat",props:{"-isView":1,"-transfer":1}},"-bind":{cat:"nat",props:null},"-Boolean":{cat:"nat",props:null},"-call":{cat:"nat",props:null},"-charAt":{cat:"nat",props:null},"-charCodeAt":{cat:"nat",props:null},"-clearInterval":{cat:"nat",props:null},"-clearTimeout":{cat:"nat",props:null},"-concat":{cat:"nat",
props:null},"-constructor":{cat:"nat",props:null},"-DataView":{cat:"nat",props:null},"-Date":{cat:"nat",props:{"-UTC":1,"-now":1,"-parse":1}},"-decodeURI":{cat:"nat",props:null},"-decodeURIComponent":{cat:"nat",props:null},"-encodeURI":{cat:"nat",props:null},"-encodeURIComponent":{cat:"nat",props:null},"-Error":{cat:"nat",props:null},"-escape":{cat:"nat",props:null},"-eval":{cat:"nat",props:null},"-EvalError":{cat:"nat",props:null},"-fromCharCode":{cat:"nat",props:null},"-Function":{cat:"nat",props:null},
"-Generator":{cat:"nat",props:null},"-GeneratorFunction":{cat:"nat",props:null},"-getDate":{cat:"nat",props:null},"-getDay":{cat:"nat",props:null},"-getFullYear":{cat:"nat",props:null},"-getHours":{cat:"nat",props:null},"-getMilliseconds":{cat:"nat",props:null},"-getMinutes":{cat:"nat",props:null},"-getMonth":{cat:"nat",props:null},"-getSeconds":{cat:"nat",props:null},"-getTime":{cat:"nat",props:null},"-getTimezoneOffset":{cat:"nat",props:null},"-getUTCDate":{cat:"nat",props:null},"-getUTCDay":{cat:"nat",
props:null},"-getUTCFullYear":{cat:"nat",props:null},"-getUTCHours":{cat:"nat",props:null},"-getUTCMilliseconds":{cat:"nat",props:null},"-getUTCMinutes":{cat:"nat",props:null},"-getUTCMonth":{cat:"nat",props:null},"-getUTCSeconds":{cat:"nat",props:null},"-getYear":{cat:"nat",props:null},"-hasOwnProperty":{cat:"nat",props:null},"-indexOf":{cat:"nat",props:null},"-isFinite":{cat:"nat",props:null},"-isNaN":{cat:"nat",props:null},"-isPrototypeOf":{cat:"nat",props:null},"-join":{cat:"nat",props:null},
"-JSON":{cat:"nat",props:{"-parse":1,"-stringify":1}},"-lastIndexOf":{cat:"nat",props:null},"-length":{cat:"nat",props:null},"-match":{cat:"nat",props:null},"-Math":{cat:"nat",props:{"-abs":1,"-acos":1,"-asin":1,"-atan":1,"-atan2":1,"-ceil":1,"-cos":1,"-exp":1,"-floor":1,"-log":1,"-max":1,"-min":1,"-pow":1,"-random":1,"-round":1,"-sin":1,"-sqrt":1,"-tan":1}},"-Number":{cat:"nat",props:{"-EPSILON":1,"-isNaN":1,"-isFinite":1,"-isInteger":1,"-isSafeInteger":1,"-MAX_SAFE_INTEGER":1,"-MAX_VALUE":1,"-MIN_SAFE_INTEGER":1,
"-MIN_VALUE":1,"-NaN":1,"-NEGATIVE_INFINITY":1,"-parseFloat":1,"-parseInt":1,"-POSITIVE_INFINITY":1}},"-Object":{cat:"nat",props:{"-assign":1,"-create":1,"-defineProperty":1,"-defineProperties":1,"-freeze":1,"-getOwnPropertyDescriptor":1,"-getOwnPropertyNames":1,"-getOwnPropertySymbols":1,"-getPrototypeOf":1,"-is":1,"-isExtensible":1,"-isFrozen":1,"-isSealed":1,"-keys":1,"-observe":1,"-preventExtensions":1,"-seal":1,"-setPrototypeOf":1}},"-parse":{cat:"nat",props:null},"-parseFloat":{cat:"nat",props:null},
"-parseInt":{cat:"nat",props:null},"-pop":{cat:"nat",props:null},"-preference":{cat:"nat",props:null},"-print":{cat:"nat",props:null},"-prototype":{cat:"nat",props:null},"-push":{cat:"nat",props:null},"-RegExp":{cat:"nat",props:null},"-replace":{cat:"nat",props:null},"-reset":{cat:"nat",props:null},"-resizeBy":{cat:"nat",props:null},"-resizeTo":{cat:"nat",props:null},"-reverse":{cat:"nat",props:null},"-search":{cat:"nat",props:null},"-setDate":{cat:"nat",props:null},"-setFullYear":{cat:"nat",props:null},
"-setHours":{cat:"nat",props:null},"-setMilliseconds":{cat:"nat",props:null},"-setInterval":{cat:"nat",props:null},"-setMinutes":{cat:"nat",props:null},"-setMonth":{cat:"nat",props:null},"-setSeconds":{cat:"nat",props:null},"-setTime":{cat:"nat",props:null},"-setTimeout":{cat:"nat",props:null},"-setUTCDate":{cat:"nat",props:null},"-setUTCFullYear":{cat:"nat",props:null},"-setUTCHours":{cat:"nat",props:null},"-setUTCMilliseconds":{cat:"nat",props:null},"-setUTCMinutes":{cat:"nat",props:null},"-setUTCMonth":{cat:"nat",
props:null},"-setUTCSeconds":{cat:"nat",props:null},"-setYear":{cat:"nat",props:null},"-shift":{cat:"nat",props:null},"-slice":{cat:"nat",props:null},"-sort":{cat:"nat",props:null},"-splice":{cat:"nat",props:null},"-split":{cat:"nat",props:null},"-String":{cat:"nat",props:{"-fromCharCode":1,"-fromCodePoint":1,"-raw":1}},"-substr":{cat:"nat",props:null},"-substring":{cat:"nat",props:null},"-Symbol":{cat:"nat",props:{"-for":1,"-keyFor":1}},"-test":{cat:"nat",props:null},"-toGMTString":{cat:"nat",props:null},
"-toLocaleString":{cat:"nat",props:null},"-toLowerCase":{cat:"nat",props:null},"-toSource":{cat:"nat",props:null},"-toString":{cat:"nat",props:null},"-toUpperCase":{cat:"nat",props:null},"-toUTCString":{cat:"nat",props:null},"-TypedArray":{cat:"nat",props:{"-BYTES_PER_ELEMENT":1,"-from":1,"-name":1,"-of":1}},"-unescape":{cat:"nat",props:null},"-unshift":{cat:"nat",props:null},"-unwatch":{cat:"nat",props:null},"-UTC":{cat:"nat",props:null},"-valueOf":{cat:"nat",props:null},"-watch":{cat:"nat",props:null},
"-write":{cat:"nat",props:null},"-writeln":{cat:"nat",props:null},"-false":{cat:"val",props:null},"-Infinity":{cat:"val",props:null},"-Nan":{cat:"val",props:null},"-null":{cat:"val",props:null},"-true":{cat:"val",props:null},"-undefined":{cat:"val",props:null},"-alert":{cat:"cli",props:null},"-anchor":{cat:"cli",props:null},"-anchors":{cat:"cli",props:null},"-appendChild":{cat:"cli",props:null},"-area":{cat:"cli",props:null},"-assign":{cat:"cli",props:null},"-back":{cat:"cli",props:null},"-big":{cat:"cli",
props:null},"-blink":{cat:"cli",props:null},"-blur":{cat:"cli",props:null},"-body":{cat:"cli",props:null},"-bold":{cat:"cli",props:null},"-button":{cat:"cli",props:null},"-byteToString":{cat:"cli",props:null},"-captureEvents":{cat:"cli",props:null},"-checkbox":{cat:"cli",props:null},"-className":{cat:"cli",props:null},"-click":{cat:"cli",props:null},"-clientHeight":{cat:"cli",props:null},"-clientInformation":{cat:"cli",props:null},"-clientWidth":{cat:"cli",props:null},"-close":{cat:"cli",props:null},
"-closed":{cat:"cli",props:null},"-confirm":{cat:"cli",props:null},"-console":{cat:"cli",props:{"-assert":1,"-group":1,"-groupCollapsed":1,"-groupEnd":1,"-log":1,"-trace":1}},"-createElement":{cat:"cli",props:null},"-crypto":{cat:"cli",props:null},"-defaultStatus":{cat:"cli",props:null},"-disableExternalCapture":{cat:"cli",props:null},"-document":{cat:"cli",props:null},"-element":{cat:"cli",props:null},"-elements":{cat:"cli",props:null},"-embed":{cat:"cli",props:null},"-embeds":{cat:"cli",props:null},
"-enableExternalCapture":{cat:"cli",props:null},"-event":{cat:"cli",props:null},"-fileUpload":{cat:"cli",props:null},"-find":{cat:"cli",props:null},"-fixed":{cat:"cli",props:null},"-focus":{cat:"cli",props:null},"-fontcolor":{cat:"cli",props:null},"-fontsize":{cat:"cli",props:null},"-form":{cat:"cli",props:null},"-forms":{cat:"cli",props:null},"-forward":{cat:"cli",props:null},"-frame":{cat:"cli",props:null},"-frames":{cat:"cli",props:null},"-frameRate":{cat:"cli",props:null},"-getComputedStyle":{cat:"cli",
props:null},"-getElementById":{cat:"cli",props:null},"-getElementsByClassName":{cat:"cli",props:null},"-getElementsByTagName":{cat:"cli",props:null},"-getOptionValueCount":{cat:"cli",props:null},"-getOptionValue":{cat:"cli",props:null},"-getPropertyValue":{cat:"cli",props:null},"-getSelection":{cat:"cli",props:null},"-go":{cat:"cli",props:null},"-handleEvent":{cat:"cli",props:null},"-hidden":{cat:"cli",props:null},"-history":{cat:"cli",props:null},"-home":{cat:"cli",props:null},"-id":{cat:"cli",props:null},
"-image":{cat:"cli",props:null},"-ImageData":{cat:"cli",props:{"-data":1,"-height":1,"-width":1}},"-images":{cat:"cli",props:null},"-innerHeight":{cat:"cli",props:null},"-innerHTML":{cat:"cli",props:null},"-innerWidth":{cat:"cli",props:null},"-italics":{cat:"cli",props:null},"-javaEnabled":{cat:"cli",props:null},"-layer":{cat:"cli",props:null},"-layers":{cat:"cli",props:null},"-link":{cat:"cli",props:null},"-location":{cat:"cli",props:null},"-mimeTypes":{cat:"cli",props:null},"-moveAbove":{cat:"cli",
props:null},"-moveBelow":{cat:"cli",props:null},"-moveBy":{cat:"cli",props:null},"-moveTo":{cat:"cli",props:null},"-moveToAbsolute":{cat:"cli",props:null},"-navigate":{cat:"cli",props:null},"-navigator":{cat:"cli",props:null},"-offscreenBuffering":{cat:"cli",props:null},"-offsetHeight":{cat:"cli",props:null},"-offsetWidth":{cat:"cli",props:null},"-open":{cat:"cli",props:null},"-opener":{cat:"cli",props:null},"-options":{cat:"cli",props:null},"-outerHeight":{cat:"cli",props:null},"-outerWidth":{cat:"cli",
props:null},"-packages":{cat:"cli",props:null},"-pageXOffset":{cat:"cli",props:null},"-pageYOffset":{cat:"cli",props:null},"-parent":{cat:"cli",props:null},"-password":{cat:"cli",props:null},"-pkcs11":{cat:"cli",props:null},"-plugins":{cat:"cli",props:null},"-prompt":{cat:"cli",props:null},"-propertyIsEnum":{cat:"cli",props:null},"-radio":{cat:"cli",props:null},"-refresh":{cat:"cli",props:null},"-releaseEvents":{cat:"cli",props:null},"-reload":{cat:"cli",props:null},"-removeChild":{cat:"cli",props:null},
"-routeEvent":{cat:"cli",props:null},"-screen":{cat:"cli",props:null},"-screenX":{cat:"cli",props:null},"-screenY":{cat:"cli",props:null},"-scroll":{cat:"cli",props:null},"-scrollBy":{cat:"cli",props:null},"-scrollTo":{cat:"cli",props:null},"-secure":{cat:"cli",props:null},"-select":{cat:"cli",props:null},"-self":{cat:"cli",props:null},"-small":{cat:"cli",props:null},"-status":{cat:"cli",props:null},"-stop":{cat:"cli",props:null},"-strike":{cat:"cli",props:null},"-style":{cat:"cli",props:null},"-submit":{cat:"cli",
props:null},"-sup":{cat:"cli",props:null},"-taint":{cat:"cli",props:null},"-taintEnabled":{cat:"cli",props:null},"-text":{cat:"cli",props:null},"-textContent":{cat:"cli",props:null},"-textarea":{cat:"cli",props:null},"-top":{cat:"cli",props:null},"-untaint":{cat:"cli",props:null},"-window":{cat:"cli",props:null},"-$":{cat:"jqu",props:null},"-jQuery":{cat:"jqu",props:null}},g,p=function(){function b(a){switch(e[a]){case ">":d[a]="&gt;";break;case "<":d[a]="&lt;"}}function p(a){for(;;){++a;if(a>=x)return a;
switch(e[a]){case "*":if("/"===e[a+1])return++a;break;case ">":case "<":b(a)}}}function h(a){var d;for(d=e[a];;){++a;if(a===x)return--a;switch(e[a]){case d:if("\\"!==e[a-1])return a;break;case ">":case "<":b(a)}}}function u(a){d[a]='<span class="str">'+e[a];a=h(a);d[a]+="</span>";return a}function m(a){d[a]='<span class="brc">'+e[a]+"</span>";return a}function n(a){d[a]='<span class="opr">'+("<"===e[a]?"&lt;":">"===e[a]?"&gt;":e[a])+"</span>";return a}function A(a){d[a]='<span class="per">.</span>';
return a}function q(a){d[a]='<span class="num">'+e[a];a:{var b;b=e[a]+e[a+1];for(b="0x"===b||"0X"===b?c:f;;){if(a===x-1)break a;if(!b.test(e[a+1]))break a;++a}}d[a]+="</span>";return a}function w(a,b){var c,g,h,f;a:for(h=a,g="-";;){g+=e[h];if(h===x-1){c=h;h=void 0;break a}if(!s.test(e[h+1])){c=h;h="."===e[h+1];break a}++h}t[g]&&(f=t[g].cat,f=r[f],"-function"===g&&("("===e[c+1]||" "===e[c+1]&&"("===e[c+2])&&(f=r.res));!f&&b&&t[b].props[g]&&(f=t[b].cat,f=r[f]);d[a]='<span class="'+(f||"idt")+'">'+e[a];
d[c]+="</span>";a=c;h&&(A(++a),b=t[g]?t[g].props?g:void 0:void 0,a=w(++a,b));return a}var d,e,x,y={"'":function(a){return u(a)},'"':function(a){return u(a)}," ":function(a){d[a]='<span class="spc"> ';a:for(;;){if(" "!==e[a+1])break a;++a}d[a]+="</span>";return a},"{":function(a){return m(a)},"[":function(a){return m(a)},"(":function(a){return m(a)},")":function(a){return m(a)},"]":function(a){return m(a)},"}":function(a){return m(a)},"*":function(a){return n(a)},"%":function(a){return n(a)},"+":function(a){return n(a)},
"-":function(a){return n(a)},"<":function(a){return n(a)},">":function(a){return n(a)},"&":function(a){return n(a)},"^":function(a){return n(a)},"|":function(a){return n(a)},"=":function(a){return n(a)},"!":function(a){return n(a)},"~":function(a){return n(a)},"?":function(a){return n(a)},",":function(a){d[a]='<span class="cmm">,</span>';return a},";":function(a){d[a]='<span class="smc">;</span>';return a},":":function(a){d[a]='<span class="cln">:</span>';return a},".":function(a){return A(a)},0:function(a){return q(a)},
1:function(a){return q(a)},2:function(a){return q(a)},3:function(a){return q(a)},4:function(a){return q(a)},5:function(a){return q(a)},6:function(a){return q(a)},7:function(a){return q(a)},8:function(a){return q(a)},9:function(a){return q(a)},"/":function(a){switch(e[a+1]){case "/":return d[a]='<span class="cmt">/',a=x-1,d[a]+="</span>",a;case "*":return d[a]='<span class="cmt">/',a=p(++a),a===x&&(g=!0,--a),d[a]+="</span>",a;default:if(-1!==k.indexOf(0===a?"(":" "===e[a-1]?e[a-2]:e[a-1])){var b;d[a]=
'<span class="rgx">/';a=h(a);b=[];a:for(;;){if(3===b.length)break a;switch(e[a+1]){case "g":case "i":case "m":if(-1!==b.indexOf(e[a+1]))break a;b.push(e[a+1]);++a;break;default:break a}}d[a]+="</span>";return a}return n(a)}}};return{init:function(a){e=a.split("");x=e.length;d=e.slice();a:{a=0;if(g&&(d[a]="*"===e[a]?" ":"",d[a]+='<span class="cmt">'+e[a],"*"===e[0]&&"/"===e[1]?(g=!1,d[1]+="</span>",a=3):(a=p(a),a<x?(g=!1,d[a]+="</span>",++a):d[a-1]+="</span>"),a===x)){a=d.join("");break a}for(;a<x;a++)y[e[a]]?
a=y[e[a]](a):l.test(e[a])?a=w(a):d[a]='<span class="msc">'+e[a]+"</span>";a=d.join("")}return a}}}();return{init:function(c){c=String(c).replace(/\r\n?/g,"\n").replace(/\t/g," ").split("\n");var f,h,l;b=0;g=!1;l=c.length;for(f=0;f<c.length;f++){h=c[f];var m=void 0,n=void 0,k=void 0,q=void 0;h=h.split("");n=h.length;k=n-1;q={code:"",first:"",last:"",padding:0,empty:!1};m=0;a:for(;m<n;m++){if(" "===h[m])h[m]="";else{q.first=h[m];break a}m===k&&(q.empty=!0)}if(!q.empty)a:for(m=k;0<=m;m--)if(" "===h[m])h[m]=
"";else{q.last=h[m];break a}q.code=h.join("");h=q;if(!h.empty){m=h;n=h.last;k=void 0;switch(h.first){case "}":case "]":case ")":--b}k=20*b;switch(n){case "{":case "[":case "(":case "?":++b}m.padding=k}h.empty||(h.code=p.init(h.code));c[f]='<li style="padding-left:'+h.padding+'px">'+h.code+"</li>"}return{result:c.join(""),lineCount:l}}}}()})(questions);}());
