/* Algorithm IV (v1.0.0) (learn@algorithmiv.com)
 * Section: User Data, App Initialization, & Web Worker
 * Author: Adam Smith (adamsmith@youlum.com)
 * Copyright (c) 2015 Adam A Smith (github.com/imaginate)
 * The MIT License (algorithmiv.com/docs/license) */

/**
 * ------------------------------------------------------------------
 * Algorithm IV User Data (v1.0.0)
 * ------------------------------------------------------------------
 * manages a list of practice questions and detailed solutions
    for learning computer science focused algorithms and data
    structures, improving programming skillsets, and preparing
    for technical interviews
 * settings: configuration, categories, sources, and questions
 * directions:
   - see algorithmiv.com/docs/start
 */
(function() {
  "use strict";

  /**
   * -----------------------------------------------
   * Public Variable (configuration)
   * -----------------------------------------------
   * an object containing the configuration settings
      for this module
   * details:
     - see algorithmiv.com/docs/configuration
   */
  var configuration = {
    searchSettings: {
         stage: true,
        source: true,
      category: true,
        subCat: true
    },
    searchDefaults: {
         view: 'one',
        order: 'asc',
        stage: 'all',
       source: 'all',
      mainCat: 'all',
       subCat: 'all',
      startID: 0
    },
    questionFormat: {
            id: true,
      complete: true,
        source: true,
      category: true,
         links: true,
        output: true
    },
    prettyCode: {
      lineHeight: 26
    },
        id: true,
    worker: true
  };

  /**
   * -----------------------------------------------
   * Public Variable (sources)
   * -----------------------------------------------
   * an object containing all of the problem sources
   * details:
     - see algorithmiv.com/docs/sources
   */
  var sources = {
    'am': 'Amazon',
    'bl': 'Bloomberg',
    'fb': 'Facebook',
    'go': 'Google'
  };

  /**
   * -----------------------------------------------
   * Public Variable (categories)
   * -----------------------------------------------
   * an object containing each main and sub question
     category
   * details:
     - see algorithmiv.com/docs/categories
   */
  var categories = {
    main: {
      'graph' : 'Graphs',
      'hash'  : 'Hash Tables',
      'heap'  : 'Heaps',
      'search': 'Searching Algorithms',
      'sort'  : 'Sorting Algorithms',
      'tree'  : 'Trees'
    },
    sub: {
      'graph': {
        'digraph': 'Directed Graphs'
      },
      'hash': {
        'dblHash': 'Double Hashing'
      },
      'search': {
        'back' : 'Backtracking',
        'bfs'  : 'Breadth First Search',
        'brute': 'Brute Force Search',
        'dfs'  : 'Depth First Search'
      },
      'tree': {
        'binTree': 'Binary Trees',
        'trie'   : 'Tries'
      }
    }
  };

  /**
   * ---------------------------------------------
   * Public Variable (questions)
   * ---------------------------------------------
   * an array of objects containing each question,
      its details, and your solution for it
   * details:
     - see algorithmiv.com/docs/questions
   */
  var questions = [
    {
      // Question: 1
      complete: true,
        source: 'fb',
       mainCat: [ 'search', 'tree' ],
        subCat: [ 'bfs', 'binTree' ],
         links: [
           {
             name: 'Further Discussion',
             href: 'http://www.careercup.com/question?id=4505011482525696'
           }
         ],
       problem: 'Write a function that prints the rows of a binary tree, terminating each row with a carriage return.',
      solution: function() {
        /*
         ** Solution:
         *  - A basic Breadth First Search algorithm is used
         *  to traverse the data structure for this solution.
         *
         ** Need to Know Terms:
         *  - Algorithms:
         *    -- Breadth First Search (BFS): http://en.wikipedia.org/wiki/Breadth-first_search
         *  - Data Structures:
         *    -- Binary Tree: http://en.wikipedia.org/wiki/Binary_tree
         */

        // Set test data
        var graph = [
          { node:  0, links: [ 1, 2] },
          { node:  1, links: [ 3, 4] },
          { node:  2, links: [ 5, 6] },
          { node:  3, links: [ 7, 8] },
          { node:  4, links: [ 9,10] },
          { node:  5, links: [11,12] },
          { node:  6, links: [13,14] },
          { node:  7, links: [] },
          { node:  8, links: [] },
          { node:  9, links: [] },
          { node: 10, links: [] },
          { node: 11, links: [] },
          { node: 12, links: [] },
          { node: 13, links: [] },
          { node: 14, links: [] }
        ];

        // The BFS function
        function printNodes() {
          // The list of current nodes to be searched
          // The current node being searched
          // The max number of nodes for the current row
          // The current number of nodes on the current row
          // The final string of nodes by row
          // The number of children the current node contains
          // The current child
          var list, node, rowMax, rowCount, result, childCount, child;

          // Set list to array with node 0
          list = [0];
          // Set max of first row to 1
          rowMax = 1;
          // Set current row count to 0
          rowCount = 0;
          // Set result to empty string
          result = '';

          // Loop through nodes
          while (list.length > 0) {

            // Set current node to first 
            node = list[0];
            // Remove current node from list
            list.splice(0, 1);
            // Increase the count by one
            ++rowCount;
            // Set result
            result += node + ( (rowMax === rowCount) ? '<br />' : ',' );

            // If (level finished)
            // Then {double it}
            if (rowMax === rowCount) {
              rowMax = rowMax * 2;
              rowCount = 0;
            }

            // Save current node's child count
            childCount = graph[node].links.length;

            // Add current node's children to list
            for (child=0; child<childCount; child++) {
              list.push(graph[node].links[child]);
            }
          }

          // Return the resulting BST
          return result;
        }
        
        // Run and return the BST function
        return printNodes();
      }
    },
    {
      // Question: 2
      complete: true,
        source: 'am',
       mainCat: [ 'search', 'graph' ],
        subCat: [ 'back', 'dfs', 'digraph' ],
         links: [
           {
             name: 'Further Discussion',
             href: 'http://www.careercup.com/question?id=6031402409656320'
           }
         ],
       problem: 'Imagine a large city like Los Angeles. Suppose someone shows up at location A, then N minutes later at location B. Design a function that approximates the probability they passed a Starbucks.',
      solution: function() {
        /*
         ** Solution:
         *  - A recursive backtracking algorithm is used to
         *  traverse a time weighted digraph of locations.
         *
         ** Need to Know Terms:
         *  - Algorithms:
         *    -- Backtracking: http://en.wikipedia.org/wiki/Backtracking
         *    -- Depth First Search (DFS): http://en.wikipedia.org/wiki/Depth-first_search
         *  - Data Structures:
         *    -- Directed Graph (Digraph): http://en.wikipedia.org/wiki/Directed_graph
         *    -- Weighted Graph: http://en.wikipedia.org/wiki/Glossary_of_graph_theory#Weighted_graphs_and_networks
         */

        // A list of vertices, edges, weights, and Starbucks
        // The starting node (location a)
        // The final node (location b)
        // The maximum weight of a path (max minutes of time)
        // The current path being checked
        // A string containg all the paths
        var graph, start, end, maxWeight, path, returnPaths;
        // The count of all the possible paths
        // The count of all the possible paths with a Starbucks
        // The probability of passing a Starbucks
        var allPaths, starPaths, prob;

        // Set the test data
        graph = [
          {
            node: 0,
            links: [
              { node: 1, weight: 5, starbucks: false },
              { node: 2, weight: 5, starbucks: false },
              { node: 3, weight: 5, starbucks: false }
            ]  
          },
          {
            node: 1,
            links: [
              { node: 3, weight: 5, starbucks: false },
              { node: 4, weight: 5, starbucks: false }
            ]
          },
          {
            node: 2,
            links: [
              { node: 4, weight: 5, starbucks: false },
              { node: 5, weight: 5, starbucks:  true }
            ]
          },
          {
            node: 3,
            links: [
              { node: 6, weight: 5, starbucks: false }
            ]
          },
          {
            node: 4,
            links: [
              { node: 6, weight: 5, starbucks: false }
            ]
          },
          {
            node: 5,
            links: [
              { node: 7, weight: 5, starbucks: false },
              { node: 8, weight: 5, starbucks: false },
              { node: 9, weight: 5, starbucks: false }
            ]
          },
          {
            node: 6,
            links: [
              { node: 7, weight: 5, starbucks: false },
              { node: 9, weight: 5, starbucks: false }
            ]
          },
          {
            node: 7,
            links: [
              { node: 8, weight: 5, starbucks: false }
            ]
          },
          {
            node: 8,
            links: [
              { node: 9, weight: 5, starbucks: false }
            ]
          }
        ];
        start = 0;
        end = 9;
        maxWeight = 20;
        path = [];
        returnPaths = '';
        allPaths = 0;
        starPaths = 0;

        // The backtracking algorithm
        // param: The current node
        // param: The current cumulative weight
        // param: Whether a starbucks currently exists
        function findPaths(node, weight, starbucks) {
          // The number of children the current node contains
          // An index for traversing all the current node's children
          // The object containing all of the current child's info
          // The new total path weight after child's weight has been added
          // The new starbucks value
          var childCount, c, child, newWeight, newStar;

          // If (weight is greater than max weight)
          // Then {end this path traversal}
          if (weight > maxWeight) {
            return;
          }

          // If (node is destination)
          if (node === end) {
            // Add path to return string
            returnPaths += '{ ' +
              'path: [' + path + ',' + end + '],' +
              'starbucks: ' + ( (starbucks) ? ' true' : 'false' ) +
            ' }<br />';
            // Add path to total counts
            ++allPaths;
            starPaths += (starbucks) ? 1 : 0;
            // End path traversal
            return;
          }

          // Add node to current path
          path.push(node);
          // Save the number of children
          //  for the current node
          childCount = graph[node].links.length;

          // Find each child's path
          for (c=0; c<childCount; c++) {
            // Set child object
            child = graph[node].links[c];
            // Set new weight total
            newWeight = weight + child.weight;
            // Set new value for starbucks
            newStar = ( (starbucks || child.starbucks) ?
              true : false
            );
            // Call algorithm
            findPaths(child.node, newWeight, newStar);
          }

          // Remove current node from path
          path.pop();
        }

        // Calculate the number of paths
        findPaths(start, 0, false);
        
        // Calculate probability of passing a Starbucks
        prob = (starPaths / allPaths) * 100;
        prob = Math.ceil(prob);

        // Return details
        return 'All Paths: ' + allPaths + '<br />' +
               'Paths with Starbucks: ' + starPaths + '<br />' +
               'Probability of passing Starbucks: ' + prob + '%<br />' +
               'List of All Paths:<br />' + returnPaths;
      }
    },
    {
      // Question: 3
      complete: true,
        source: 'go',
       mainCat: [ 'hash' ],
        subCat: [ 'dblHash' ],
         links: [
           {
             name: 'Further Discussion',
             href: 'http://www.careercup.com/question?id=5724911848914944'
           }
         ],
       problem: 'Given a table of [Url =&gt; Content] pairs produce a new table of [Url =&gt; Duplicate Urls] pairs.<br /><br />' +
                'Example Input:<br />' +
                'a.com =&gt; &lt;html&gt;a&lt;/html&gt;<br />' +
                'b.com =&gt; &lt;html&gt;b&lt;/html&gt;<br />' +
                'c.com =&gt; &lt;html&gt;c&lt;/html&gt;<br />' +
                'd.com =&gt; &lt;html&gt;a&lt;/html&gt;<br />' +
                'e.com =&gt; &lt;html&gt;a&lt;/html&gt;<br /><br />' +
                'Example Output:<br />' +
                'a.com =&gt; [d.com, e.com]<br />' +
                'b.com =&gt; []<br />' +
                'c.com =&gt; []',
      solution: function() {
        /*
         ** Solution:
         *  - A modified FNV-1a hash algorithm is used to create a
         *  hash table for each url's content. Then the hashes of
         *  each url are compared to identify duplicates.
         *
         ** Need to Know Terms:
         *  - Algorithms:
         *    -- FNV Hash Algorithm: http://www.isthe.com/chongo/tech/comp/fnv/
         *    -- Double Hashing: http://en.wikipedia.org/wiki/Double_hashing
         *  - Data Structures:
         *    -- Hash Table: http://en.wikipedia.org/wiki/Hash_table
         */
        
        // Supplied urls and their content
        var inputs;

        // Setup variables
        inputs = {
          'a.com': '<html>a</html>',
          'b.com': '<html>b</html>',
          'c.com': '<html>c</html>',
          'd.com': '<html>a</html>',
          'e.com': '<html>a</html>'
        };

        // FNV-1a hash algorithm
        // param: The string to be hashed
        // param: The extra times to hash
        function createHash(string, extras) {
          // The resulting hash
          // The string length
          // Loop index
          var hash, len, i;

          // Set extras
          extras = extras || 0;
          // Set hash to 32 bit FNV offset_basis
          hash = 2166136261;
          // Save string length
          len = string.length;

          // Loop through each string character
          for (i=0; i<len; i++) {
            // XOR first
            hash = hash ^ string.charAt(i);
            // Multiply by 32 bit FNV_prime
            hash = hash * 16777619;
          }
          
          if (extras > 0) {
            // Loop through each extra time
            for (i=0; i<extras; i++) {
              // XOR first
              hash = hash ^ string.charAt(i);
              // Multiply by 32 bit FNV_prime
              hash = hash * 16777619;
            }
          }

          // Return completed hash
          return hash;
        }

        // Create a hash table for the url content
        function createHashTable() {
          // Function that adds hash to table
          // The hash table
          // The current url
          // The current url's content
          // The current content's hash
          // Indicator to check if collision has occurred
          var addHash, hashes, url, content, hash, flag;

          // Set addHash function
          addHash = function(theUrl, theContent, theHash) {

            // If (hash does not exist in table)
            if (typeof hashes[theHash] === 'undefined') {
              // Add hash key to table
              hashes[theHash] = {
                collisions: 0,
                content: theContent
              };
              // Replace inputs content with hash
              inputs[theUrl] = theHash;
            }
            else {
              // If (no collision)
              // Then {replace inputs content with hash}
              // Else {add collision, create new hash, and repeat process}
              if (theContent === hashes[theHash].content) {
                inputs[theUrl] = theHash;
              }
              else {
                ++hashes[theHash].collisions;
                theHash = createHash(theContent, hashes[theHash].collisions);
                addHash(theUrl, theContent, theHash);
              }
            }
          }

          // Set hash table to empty object
          hashes = {};

          // Loop through supplied inputs
          for (url in inputs) {
            // Filter out default javascript properties
            if ( inputs.hasOwnProperty(url) ) {
              // Save the content
              content = inputs[url];
              // Hash url content
              hash = createHash(content);
              // Add to hash table
              addHash(url, content, hash);
            }
          }

          // Return the hash table
          return hashes;
        }

        // Create list of urls
        function createUrlList() {
          // The list of urls
          // The current url
          var urls, url;

          // Set url list to empty array
          urls = [];

          // Loop through supplied inputs
          for (url in inputs) {
            // Filter out default javascript properties
            if ( inputs.hasOwnProperty(url) ) {
              // Add url to list
              urls.push(url);
            }
          }

          // Return the list of urls
          return urls;
        }

        // Create duplicated url content
        function findDuplicates() {
          // A hash table of the url content
          // A list of the urls to check
          // The current url
          // The current hash
          // The current length of the url list
          // Loop index
          // The next url
          // Loop count
          // The resulting duplicates
          var hashes, urls, url, hash, len, i, next, c, duplicates;

          // Set hashes, urls, and duplicates
          hashes = createHashTable();
          urls = createUrlList();
          duplicates = {};

          // Loop through url list
          while (urls.length > 0) {

            // Save and remove first url on list
            url = urls.shift();
            // Save hash of current url's content
            hash = createHash(inputs[url]);
            // Add url to list of duplicates
            duplicates[url] = [];
            // Save the current url list length
            len = urls.length;
            // Set index and count to 0
            i = c = 0;

            // Loop through url list
            loop:
            while (true) {

              // If (count is equal to length)
              // Then {end loop}
              if (c === len) {
                break loop;
              }
              // Save next url
              next = urls[i];
              
              // If (urls content matches)
              // Then {save to duplicates and remove from url list}
              // Else {increase index}
              if (inputs[url] === inputs[next]) {
                duplicates[url].push(next);
                urls.splice(i, 1);
              }
              else {
                ++i;
              }

              // Add one to count
              ++c;
            }
          }
          
          // Return the duplicates
          return duplicates;
        }

        // Prepare results to be returned
        function prepareResults() {
          // The duplicates
          // The results
          // The current url
          var duplicates, results, url;

          // Set duplicates and results
          duplicates = findDuplicates();
          results = '';

          // Loop through results
          for (url in duplicates) {
            // Filter out default javascript properties
            if ( duplicates.hasOwnProperty(url) ) {
              // Add url to results
              results += url + ' => [' + duplicates[url].join(',') + ']<br />';
            }
          }

          // Return results
          return results;
        }

      return prepareResults();
      }
    },
    {
      // Question: 4
      complete: true,
        source: 'go',
       mainCat: [ 'search', 'tree', 'graph' ],
        subCat: [ 'brute', 'back', 'dfs', 'trie', 'digraph' ],
         links: [
           {
             name: 'Further Discussion',
             href: 'http://www.careercup.com/question?id=6270813198090240'
           }
         ],
       problem: 'You are given a string of four lower case characters and a dictionary of english words. Choose a data structure to represent the dictionary and write an algorithm that returns all the words from the dictionary that can be formed by the characters of the string.<br />' +
                'Example:<br />' +
                'string = \'ogeg\'<br />' +
                'words = [ \'go\',\'egg\',\'ego\', ... ]',
      solution: function() {
        /*
         ** Solution:
         *  - A brute force algorithm is used to create a trie
         *  from the supplied list of words. Then a digraph is
         *  constructed for all of the characters in the
         *  supplied string. Finally a backtracking algorithm
         *  is used to find the possible words resulting from
         *  the digraph of the supplied string.
         *
         ** Need to Know Terms:
         *  - Algorithms:
         *    -- Brute Force: http://en.wikipedia.org/wiki/Brute-force_search
         *    -- Backtracking: http://en.wikipedia.org/wiki/Backtracking
         *    -- Depth First Search (DFS): http://en.wikipedia.org/wiki/Depth-first_search
         *  - Data Structures:
         *    -- Trie: http://www.geeksforgeeks.org/trie-insert-and-search/
         *    -- Double-Array Trie: http://linux.thai.net/~thep/datrie/
         *    -- Directed Graph (Digraph): http://en.wikipedia.org/wiki/Directed_graph
         *
         ** Copyright Notice:
         *  - The list of English words used to create the test data
         *  for this question was derived from the EOWL and UKACD.
         *  - See github.com/imaginate/algorithmIV/blob/master/example/resources/words.json
         *  - See http://dreamsteep.com/projects/the-english-open-word-list.html
         *  - Copyright (c) J Ross Beresford 1993-1999. All Rights Reserved.
         *  - Copyright Details: http://cfajohnson.com/wordfinder/UKACD17.shtml 
         */

        // A list of English words for this test
        // A trie of words with a max length of 4
        //   characters and starting with each of
        //   the string's characters
        // The input string
        // The resulting possible words from the string
        var words, wordTrie, string, results;

        // Setup variables
        words    = {};
        wordTrie = {};
        string   = 'dane';
        results  = [];

        // Create the trie of words
        function createWordTrie() {
          // The supplied string
          // The current letter
          // The index of the last duplicate letter
          var theString, letter, lastDupl;

          // Save a copy of the string as an array
          theString = string.split('');
          theString.sort();

          // Loop through characters
          while (theString.length > 0) {

            // Save letter and remove letter from string
            letter = theString.shift();
            // Save index of last duplicate
            lastDupl = theString.lastIndexOf(letter);
            // If (letter duplicates exist in string)
            // Then {remove each one}
            if (lastDupl !== -1) {
              theString.splice(0, lastDupl);
            }
            // Add a branch to the trie
            addTrieBranch(letter);
          }
        }

        // Adds a branch to the root of trie
        // param: the letter branch to create
        function addTrieBranch(letter) {
          // The word loop index
          // The count of words
          // The current word
          // The current word length
          // An array of the word's characters
          // The character loop index
          var i, wordsLen, word, wordLen, characters, c;
          // The last character index
          // The current string of characters
          // The current character
          var last, current, character;
          
          // Add branch to trie
          wordTrie[letter] = {
            isWord: false,
              kids: []
          };
          // Save words length
          wordsLen = words[letter].length;

          // Loop through words
          for (i=0; i<wordsLen; i++) {
            
            // Save word and word length
            word = words[letter][i];
            wordLen = word.length;

            // If (word has less than 5 characters)
            // Then {add word to trie}
            if (wordLen < 5) {

              // If (word is one character)
              // Then {set root end prop to true}
              // Else {add word to trie}
              if (wordLen === 1) {
                wordTrie[letter].isWord = true;
              }
              else {

                // Save last index
                last = wordLen - 1;
                // Create array of characters
                characters = word.split('');
                // Save current string of characters
                current = letter;            

                // Loop through remaining characters
                for (c=1; c<=last; c++) {

                  // Save current character
                  character = characters[c];
                  // If (character not in parent's list of kids)
                  // Then {add character}
                  if (wordTrie[current].kids.indexOf(character) === -1) {
                    wordTrie[current].kids.push(character);
                  }
                  // Update current string
                  current += character;
                  // If (current string does not exist)
                  // Then {add to trie}
                  // Else {update isWord}
                  if (typeof wordTrie[current] === 'undefined') {
                    wordTrie[current] = {
                      isWord: (c === last),
                        kids: []
                    };
                  }
                  else {
                    wordTrie[current].isWord = ( (wordTrie[current].isWord) ?
                      true : (c === last)
                    );
                  }
                }
              }
            }
          }
        }

        // Create digraph of supplied string
        function createDigraph() {
          // The supplied string as an array
          // The digraph of the string
          // The first loop index
          // The current list
          // The second loop index
          // The remaining characters
          var theString, graph, i, list, x, remain;

          // Set the variables
          theString = string.split('');
          graph = {};

          // Loop through characters
          for (i=0; i<4; i++) {

            // Add character to graph
            graph[theString[i]] = {};
            // Save current list
            list = theString.slice(0);
            list.splice(i, 1);
            
            // Loop through remaining characters
            for (x=0; x<3; x++) {

              // Add character to children
              graph[theString[i]][list[x]] = {};
              // Save remaining characters
              remain = list.slice(0);
              remain.splice(x, 1);
              // Add remaining children to graph
              graph[theString[i]][list[x]][remain[0]] = remain[1];
              graph[theString[i]][list[x]][remain[1]] = remain[0];
            }
          }

          return graph;
        }

        // Finds all of the possible words resulting from the string
        function findWords() {
          // Digraph of string
          // A function to recursively handle the DFS
          var graph, backtrack;

          // Recursively backtrack to find words
          // param: The current node
          // param: The current word to be checked
          backtrack = function(node, word) {
            // The child node
            // The new word
            var child, newWord;

            // If (word is undefined)
            // Then {set to empty string}
            word = word || '';

            // Loop through string
            for (child in node) {
              // Filter out default javascript properties
              if ( node.hasOwnProperty(child) ) {

                // Add character to create new word
                newWord = word + child;

                // If (partial word exists)
                // Then {continue search}
                if (typeof wordTrie[newWord] === 'object') {

                  // If (partial word is complete)
                  // Then {add word to results}
                  if (wordTrie[newWord].isWord) {
                    results.push(newWord);
                  }

                  // If (child has children)
                  // Then {repeat backtrack}
                  // Else {modify and check word}
                  if (typeof node[child] === 'object') {
                    backtrack(node[child], newWord);
                  }
                  else {
                    // Verify error has not occurred
                    if (typeof node[child] === 'string') {

                      // Add child to word and check again
                      newWord += node[child];
                      if (typeof wordTrie[newWord] === 'object') {
                        if (wordTrie[newWord].isWord) {
                          results.push(newWord);
                        }
                      }
                    }
                  }
                }
              }
            }
          }

          // Set string digraph
          graph = createDigraph();
          // Start recursive search
          backtrack(graph);
        }

        // Download the json dictionary
        function makeAjaxCall() {
          // Contains the ajax call
          var http;

          http = new XMLHttpRequest();
          http.onreadystatechange = function() {
            // If (ajax finished)
            if (http.readyState === 4 && http.status === 200) {
              // Sanitize and set the words list
              words = JSON.parse(http.responseText);
            }
          };
          http.open('GET', 'resources/words.json', false);
          http.send();
        }

        // Trigger ajax
        makeAjaxCall();
        // Create the trie of words
        createWordTrie();
        // Find the possible words
        findWords();
        // Return results
        return '[ ' + results.join(',') + ' ]';
      }
    },
    {
      // Question: 5
      complete: true,
        source: 'bl',
       mainCat: [ 'search','graph' ],
        subCat: [ 'dfs','digraph' ],
         links: [
           {
             name: 'Further Discussion',
             href: 'http://www.careercup.com/question?id=5768610725232640'
           }
         ],
       problem: 'Using the below node list find the path that uses all nodes without duplicating one.<br />' +
                '[ JFK,LXA,SNA,RKJ,LXA,SNA ]<br />' +
                'Note: Each pair of nodes define a directed edge like so:<br />' +
                '[ (JFK -&gt; LXA),(SNA -&gt; RKJ),(LXA -&gt; SNA) ]<br />',
      solution: function() {
        /*
         ** Solution:
         *  - First a digraph of the nodes and edges and an
         *  array of the two possible root nodes are created.
         *  Then a DFS algorithm is applied to find the path
         *  of the nodes.
         *
         ** Need to Know Terms:
         *  - Algorithms:
         *    -- Depth First Search (DFS): http://en.wikipedia.org/wiki/Depth-first_search
         *  - Data Structures:
         *    -- Directed Graph (Digraph): http://en.wikipedia.org/wiki/Directed_graph
         */

        // Original node list
        // Digraph of nodes
        // Possible root nodes
        // Final node path
        var nodes, graph, roots, nodeCount, result;

        // Set variables
        nodes = [ 'JFK','LXA','SNA','RKJ','LXA','SNA' ];
        graph = {};
        roots = [];
        result = '';

        // Add node to roots
        // param: node to add
        function addRoot(node) {
          // Index of node in roots array
          var i;

          // Save node index
          i = roots.indexOf(node);

          // If (node is not in roots)
          // Then {add to roots}
          // Else {remove from roots}
          if (i === -1) {
            roots.push(node);
          }
          else {
            roots.splice(i, 1);
          }
        }

        // Create digraph
        function createGraph() {
          // Count of node list
          // Loop index
          // The current node
          // The current edge
          var len, i, node, edge;

          // Save node list count
          len = nodes.length;

          // Loop through nodes
          for (i=0; i<len; i+=2) {

            // Save node and edge
            node = nodes[i];
            edge = nodes[i + 1];
            // Add nodes to roots
            addRoot(node);
            addRoot(edge);
            // Add node to digraph
            graph[node] = edge;
          }
        }

        // Find the root node
        function findRoot() {
          // Loop index
          var i;

          // Loop through roots
          for (i=0; i<2; ++i) {

            // If (node not in graph)
            // Then {remove it from roots}
            if (typeof graph[roots[i]] === 'undefined') {
              roots.splice(i, 1);
            }
          }
        }

        // Finds the correct path
        function findPath() {
          // The next node
          // The current node
          var next, node;

          // Set next to root node
          next = [roots[0]];

          // Run DFS
          while (next.length > 0) {

            // Save current node
            node = next.pop();
            // Add current node to final path
            result += node;
            // If (next node exists)
            // Then {add arrow to path and set next node}
            if (typeof graph[node] !== 'undefined') {
              result += ' -&gt; ';
              next.push(graph[node]);
            }
          }
        }

        createGraph();
        findRoot();
        findPath();
        return result;
      }
    },
    {
      // Question: 6
      complete: false,
        source: 'go',
       mainCat: [],
        subCat: [],
         links: [
           {
             name: 'Further Discussion',
             href: 'http://www.careercup.com/question?id=4863668900593664'
           }
         ],
       problem: 'Given a binary search tree (BST), write a mehtod that will convert this BST into a doubly linked list that is sorted (ascending or descending order) and returns the first element in this list.<br />You may assume you are given following Node class:<br /><br />public&nbsp;&nbsp;class&nbsp;&nbsp;Node&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;&nbsp;Node&nbsp;&nbsp;left, right;<br />&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;&nbsp;String&nbsp;&nbsp;val;<br />}<br /><br />Example:<br />&nbsp;&nbsp;G<br />&nbsp;/&nbsp;\\<br />A T<br />This BST can be converted into list, A = G = T<br /><br />Do it in place! The memory complexity of your algorithm shoul be O(1).',
      solution: function() {
        /*
         ** Solution:
         *  - [explanation]
         *
         ** Need to Know Terms:
         *  - Algorithms:
         *    -- [term]: [link]
         *  - Data Structures:
         *    -- [term]: [link]
         */
      }
    },
    {
      // Question: 7
      complete: false,
        source: 'fb',
       mainCat: [],
        subCat: [],
         links: [
           {
             name: 'Further Discussion',
             href: 'http://www.careercup.com/question?id=5748231105413120'
           }
         ],
       problem: 'Given a Tree:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\<br />&nbsp;&nbsp;&nbsp;B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C<br />&nbsp;&nbsp;/ \\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/ \\<br />D&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;&nbsp;F&nbsp;&nbsp;&nbsp;G<br /><br />Write a function that prints:<br />A<br />BC<br />DEFG',
      solution: function() {
        /*
         ** Solution:
         *  - [explanation]
         *
         ** Need to Know Terms:
         *  - Algorithms:
         *    -- [term]: [link]
         *  - Data Structures:
         *    -- [term]: [link]
         */
      }
    },
    {
      // Question: 8
      complete: false,
        source: 'go',
       mainCat: [],
        subCat: [],
         links: [
           {
             name: 'Further Discussion',
             href: 'http://www.careercup.com/question?id=6295449935806464'
           }
         ],
       problem: 'Represent the following in a data structure:<br />&lt;html&gt;&lt;body&gt;&lt;div&gt;&lt;span&gt;TEXT1&lt;/span&gt;&lt;br/&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;<br /><br />Do I do the same using a stack or create a tree for the same?',
      solution: function() {
        /*
         ** Solution:
         *  - [explanation]
         *
         ** Need to Know Terms:
         *  - Algorithms:
         *    -- [term]: [link]
         *  - Data Structures:
         *    -- [term]: [link]
         */
      }
    },
    {
      // Question: 9
      complete: false,
        source: 'am',
       mainCat: [],
        subCat: [],
         links: [
           {
             name: 'Further Discussion',
             href: 'http://www.careercup.com/question?id=5082499984130048'
           }
         ],
       problem: 'Design a data structure that can do the following operations in O(1) time:<br />Insert, Delete, Search, Max (returns the maximum number)<br /><br />I know delete, search and insert can be done O(1) time in a hashmap with a proper hash function, but not sure Max is even possible in O(1) with the presence of delete operation?',
      solution: function() {
        /*
         ** Solution:
         *  - [explanation]
         *
         ** Need to Know Terms:
         *  - Algorithms:
         *    -- [term]: [link]
         *  - Data Structures:
         *    -- [term]: [link]
         */
      }
    },
    {
      // Question: 10
      complete: false,
        source: 'am',
       mainCat: [],
        subCat: [],
         links: [
           {
             name: 'Further Discussion',
             href: 'http://www.careercup.com/question?id=6260358392053760'
           }
         ],
       problem: 'You are given two integer arrays A and B.<br /><br />1&lt;=i&lt;=len(A) so i is iterator of array A<br />1&lt;=j&lt;=len(B) so j is iterator of array B<br /><br />Find all the pairs (i,j) such that : i &lt; j and A[i]&gt;B[j].',
      solution: function() { 
        /*
         ** Solution:
         *  - [explanation]
         *
         ** Need to Know Terms:
         *  - Algorithms:
         *    -- [term]: [link]
         *  - Data Structures:
         *    -- [term]: [link]
         */
      }
    }
  ];

/* ---------------------------- *
 * -- DO NOT EDIT BELOW HERE -- *
 * ---------------------------- */
(function(m,q,l,v){var n=m||{},r=q||{};l=l||{};v=v||[];n.searchSettings=m.searchSettings||{};n.searchDefaults=m.searchDefaults||{};n.questionFormat=m.questionFormat||{};n.prettyCode=m.prettyCode||{};n.prettyCode.prePadding=m.prettyCode.prePadding||{};r.main=q.main||{};r.sub=q.sub||{};"undefined"!==typeof window&&algorithmIV.init(n,r,l,v)})(configuration,categories,sources,questions);
(function(m){onmessage=function(b){b=b.data;q=b.qLen;l=b.configuration;v=b.sources;n=b.categories;r.init();self.postMessage(l.content)};var q,l={},v={},n={},r=function(){var b;return{init:function(){var s;for(s=0;s<q;s++){b={id:{flag:!1,content:""},source:{flag:!1,content:""},complete:{flag:!1,content:""},category:{flag:!1,main:{flag:!1,h3:"",p:""},sub:{flag:!1,h3:"",p:""}},solution:{error:!1,code:"",height:0},output:{flag:!1,content:""},links:{flag:!1,content:[]}};var f=void 0,e=void 0,f=l.questionFormat.id,
e="";f&&(e=s+1,e=10>e?"00"+e:100>e?"0"+e:""+e);b.id.flag=f;b.id.content=e;f=m[s].source;e=void 0;e=0<v.len&&l.questionFormat.source;b.source.flag=e;b.source.content=e?v.list[f]:"";f=m[s].complete;b.complete.flag=l.questionFormat.complete;b.complete.content=l.questionFormat.complete?f?"Yes":"No":"";var f=m[s].mainCat,e=m[s].subCat,g=void 0,r=void 0,y=void 0,t=g=void 0,h=void 0,p=g=void 0,t=void 0,g=n.len.main,t=f.length,h=e.length,g=0<g&&l.questionFormat.category,r=0<t,y=0<h;b.category.flag=g;b.category.main.flag=
r;b.category.sub.flag=y;if(g){if(r)for(b.category.main.h3="Main "+(1<t?"Categories:":"Category:"),g=0;g<t;g++)b.category.main.p+=0===g?"":", ",b.category.main.p+=n.main[f[g]];if(0<h)for(b.category.sub.h3="Sub "+(1<h?"Categories:":"Category:"),g=0;g<h;g++)a:for(p in b.category.sub.p+=0===g?"":", ",n.sub)if(n.sub.hasOwnProperty(p)&&(t=n.sub[p],"string"===typeof t[e[g]])){b.category.sub.p+=t[e[g]];break a}}f=m[s].solution;p=h=e=void 0;e="function"!==typeof f;e||(h=w.init(f),p=h.lineCount*l.prettyCode.lineHeight+
l.prettyCode.prePadding.top+l.prettyCode.prePadding.bottom);b.solution.error=e;b.solution.code=e?"":h.result;b.solution.height=e?0:p;f=m[s].solution;h=e=void 0;h=(e="function"===typeof f&&l.questionFormat.output)?f():"";h="string"!==typeof h?String(h):h;b.output.flag=e;b.output.content=h;f=m[s].links;p=h=e=void 0;h=f.length;if(e=0<h&&l.questionFormat.links)for(p=0;p<h;p++)b.links.content.push({href:f[p].href,name:f[p].name});else b.links.content=[];b.links.flag=e;l.content.push(b)}}}}(),w=function(){var b,
l="([{;*/%+-<>&^|=!".split(""),f=/[0-9\.]/,e=/[a-f0-9x\.]/i,g=/[a-z_\$]/i,m=/[a-z0-9_\$]/i,n=["class","const","function","var"],t="abstract arguments boolean break byte case catch char const continue debugger default delete do double else enum export extends final finally float for goto if implements import in instanceof int interface item let long native new package private protected public return short static super switch synchronized this throw throws transient try typeof void volatile while with yield".split(" "),
h="abs acos Array asin atan atan2 Boolean ceil charAt charCodeAt clearInterval clearTimeout concat cos Date decodeURI decodeURIComponent encodeURI encodeURIComponent escape eval exp floor fromCharCode getDate getDay getFullYear getHours getMilliseconds getMinutes getMonth getSeconds getSelection getTime getTimezoneOffset getUTCDate getUTCDay getUTCFullYear getUTCHours getUTCMilliseconds getUTCMinutes getUTCMonth getUTCSeconds getYear hasOwnProperty Image indexOf isArray isFinite isNaN isPrototypeOf join lastIndexOf length match Math max min Number Object parse parseFloat parseInt pop pow preference print prototype push random RegExp replace reset resizeBy resizeTo reverse round search select setDate setFullYear setHours setMilliseconds setInterval setMinutes setMonth setSeconds setTime setTimeout setUTCDate setUTCFullYear setUTCHours setUTCMilliseconds setUTCMinutes setUTCMonth setUTCSeconds setYear shift sin slice sort splice split sqrt String substr substring tan test toGMTString toLocaleString toLowerCase toSource toString toUpperCase toUTCString unescape unshift unwatch UTC valueOf watch write writeln".split(" "),
p="false Infinity Nan null true undefined".split(" "),r="alert all anchor anchors appendChild area assert assign back big blink blur body bold button byteToString captureEvents checkbox className clearInterval clearTimeout click clientInformation close closed confirm console constructor createElement crypto decodeURI decodeURIComponent defaultStatus disableExternalCapture document element elements embed embeds enableExternalCapture encodeURI encodeURIComponent escape event fileUpload find fixed focus fontcolor fontsize form forms forward frame frames frameRate getElementById getElementsByClassName getElementsByTagName getOptionValueCount getOptionValue go group groupCollapsed groupEnd handleEvent hidden history home id image images innerHeight innerHTML innerWidth italics javaEnabled layer layers link location log mimeTypes moveAbove moveBelow moveBy moveTo moveToAbsolute navigate navigator offscreenBuffering open opener options outerHeight outerWidth packages pageXOffset pageYOffset parent password pkcs11 plugins prompt propertyIsEnum radio refresh releaseEvents reload reset routeEvent screen screenX screenY scroll scrollBy scrollTo secure select self small status stop strike submit sup taint taintEnabled text textContent textarea top trace unescape untaint window".split(" "),
v=["$","jQuery"],q,w=function(){function b(a){switch(d[a]){case ">":c[a]="&gt;";break;case "<":c[a]="&lt;"}}function z(a){for(;;){++a;if(a>=u)return a;switch(d[a]){case "*":if("/"===d[a+1])return++a;break;case ">":case "<":b(a)}}}function k(a){var c;for(c=d[a];;){++a;if(a===u)return--a;switch(d[a]){case c:if("\\"!==d[a-1])return a;break;case ">":case "<":b(a)}}}function A(a){c[a]='<span class="operator">'+("<"===d[a]?"&lt;":">"===d[a]?"&gt;":d[a])+"</span>";return a}var c,d,u;return{init:function(a){d=
a.split("");u=d.length;c=d.slice();a:{var b;a=0;if(q&&(c[a]="*"===d[a]?' <span class="comment">*':'<span class="comment">'+d[a],"*"===d[0]&&"/"===d[1]?(q=!1,c[1]+="</span>",a=3):(a=z(a),a<u?(q=!1,c[a]+="</span>",++a):c[a-1]+="</span>"),a===u)){a=c.join("");break a}for(;a<u;a++)switch(d[a]){case "/":switch(d[a+1]){case "/":c[a]='<span class="comment">/';a=u-1;c[a]+="</span>";break;case "*":c[a]='<span class="comment">/';a=z(++a);a===u&&(q=!0,--a);c[a]+="</span>";break;default:if(b=0===a?"(":" "===
d[a-1]?d[a-2]:d[a-1],-1!==l.indexOf(b)){b=void 0;c[a]='<span class="regex">/';a=k(a);b=[];b:for(;;){if(3===b.length)break b;switch(d[a+1]){case "g":case "i":case "m":if(-1!==b.indexOf(d[a+1]))break b;b.push(d[a+1]);++a;break;default:break b}}c[a]+="</span>"}else a=A(a)}break;case "'":case '"':c[a]='<span class="string">'+d[a];a=k(a);c[a]+="</span>";break;case " ":c[a]='<span class="space"> ';b:for(;;){if(" "!==d[a+1])break b;++a}c[a]+="</span>";break;case "{":case "[":case "(":case ")":case "]":case "}":c[a]=
'<span class="bracket">'+d[a]+"</span>";break;case "*":case "%":case "+":case "-":case "<":case ">":case "&":case "^":case "|":case "=":case "!":case "~":case "?":a=A(a);break;case ",":c[a]='<span class="comma">,</span>';break;case ";":c[a]='<span class="semicolon">;</span>';break;case ":":c[a]='<span class="colon">:</span>';break;case ".":c[a]='<span class="period">.</span>';break;case "0":case "1":case "2":case "3":case "4":case "5":case "6":case "7":case "8":case "9":c[a]='<span class="number">'+
d[a];b:for(b=b=void 0,b=d[a]+d[a+1],b="0x"===b||"0X"===b?e:f;;){if(a===u-1||!b.test(d[a+1]))break b;++a}c[a]+="</span>";break;default:if(g.test(d[a])){b=void 0;b:{b=a;for(var x=void 0,x=[];;){x.push(d[b]);if(b===u-1||!m.test(d[b+1])){b={index:b,name:x.join("")};break b}++b}}switch(!0){case -1!==n.indexOf(b.name):c[a]="function"==b.name?"("===d[b.index+1]||" "===d[b.index+1]&&"("===d[b.index+2]?'<span class="reservedKeyword">'+d[a]:'<span class="definingKeyword">'+d[a]:'<span class="definingKeyword">'+
d[a];break;case -1!==t.indexOf(b.name):c[a]='<span class="reservedKeyword">'+d[a];break;case -1!==h.indexOf(b.name):c[a]='<span class="nativeKeyword">'+d[a];break;case -1!==p.indexOf(b.name):c[a]='<span class="valueKeyword">'+d[a];break;case -1!==r.indexOf(b.name):c[a]='<span class="clientKeyword">'+d[a];break;case -1!==v.indexOf(b.name):c[a]='<span class="jqueryKeyword">'+d[a];break;default:c[a]='<span class="identifier">'+d[a]}c[b.index]+="</span>";a=b.index}else c[a]='<span class="misc">'+d[a]+
"</span>"}a=c.join("")}return a}}}();return{init:function(e){e=String(e).replace(/\r\n?/g,"\n").replace(/\t/g," ").split("\n");var f,k,h;b=0;q=!1;h=e.length;for(f=0;f<e.length;f++){k=e[f];var c=void 0,d=void 0,g=void 0,a=void 0;k=k.split("");d=k.length;g=d-1;a={code:"",first:"",last:"",padding:0,empty:!1};c=0;a:for(;c<d;c++){if(" "===k[c])k[c]="";else{a.first=k[c];break a}c===g&&(a.empty=!0)}if(!a.empty)a:for(c=g;0<=c;c--)if(" "===k[c])k[c]="";else{a.last=k[c];break a}a.code=k.join("");k=a;if(!k.empty){c=
k;d=k.last;g=void 0;switch(k.first){case "}":case "]":case ")":--b}g=20*b;switch(d){case "{":case "[":case "(":case "?":++b}c.padding=g}k.empty||(k.code=w.init(k.code));e[f]='<li style="padding-left:'+k.padding+'px">'+k.code+"</li>"}return{result:e.join(""),lineCount:h}}}}()})(questions);}());
